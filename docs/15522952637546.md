# THE Update Framework

## 安全
如果可以做到以下几点，我们可以认定一个软件更新是安全的：
- 我们可以及时了解最新的可用更新
- 下载的任何文件都是正确的文件
- 检查或下载文件不会造成伤害

## 攻击和漏洞
以下是对软件更新系统的一些已知攻击，包括使这些攻击成为可能的漏洞。为了设计一个安全的软件更新框架，需要理解这些攻击，并且必须指定防御策略。根据给定软件更新系统的设计和实现，这些问题中的一些是相关的，或者可能是相关的。
- **任意软件安装**。攻击者可以响应下载请求提供任意文件，并在客户端系统上安装任何他想要的文件，但没有任何文件会被检测为非法文件。
- **回滚攻击**。攻击者向软件更新系统提交的文件比客户端已经看到的文件旧。由于无法判断这是一个可能包含漏洞的过时版本，用户安装了该软件。稍后，攻击者可以利用这些漏洞。
- **快进攻击**。攻击者任意增加快照元数据中项目元数据文件的版本号，使其远远超过当前值，从而诱使软件更新系统认为任何后续更新都试图将包回滚到以前的过时版本。在某些情况下，例如存在最大可能版本号的情况，犯罪人可能会使用一个高到系统永远无法与快照元数据中的版本号匹配的数字，因此永远无法下载新的更新。
- **无限期冻结攻击**。攻击者继续向客户端已经看到的软件更新系统文件呈现文件。因此，客户端一直不知道新文件。
- **无休止的数据攻击**。攻击者以无尽的数据流响应文件下载请求，对客户端造成损害(例如磁盘分区填满或内存耗尽)。
- **缓慢的检索攻击**。攻击者以非常慢的数据流响应客户端，这实际上导致客户端永远不会完成更新过程。
- **无关依赖攻击**。攻击者向客户端指出，为了安装他们想要的软件，他们还需要安装不相关的软件。这个额外的软件可能来自可信的来源，但仍然可能有已知的可被攻击者利用的漏洞。 
- **混搭攻击**。攻击者向客户端呈现一个存储库视图，其中包含不同时存在的文件。这可能会导致安装过时版本的依赖项，以及其他复杂情况。 
- **错误的软件安装**。攻击者向客户端提供了一个可信文件，但这并不是客户端想要的文件。 
- **阻止更新的恶意镜像**。攻击者控制一个存储库镜像，并能够使用它来阻止客户端从其他非恶意镜像获取更新。
- **易受关键妥协的影响**。攻击者可以破坏单个密钥系统中的一个密钥，或者小于给定的密钥阈值，也可以破坏客户端。无论客户端依赖于单个在线密钥(如果仅受SSL保护)还是单个离线密钥(如果受大多数使用密钥分配的软件更新系统保护)，都可能发生这些攻击。

## 安全设计原则
详情请[参考](https://theupdateframework.github.io/metadata.html)
### 信任
信任下载的文件实际上意味着假设文件是由没有恶意设计的一方提供的。安全软件更新系统中信任的两个经常被忽视的方面是: 
- 不应该永远给予信任。如果不续订，信任应该过期。 
- 信任不应平等地给予所有各方。这种划分的信任意味着一方只能被根角色规定要提供的文件所信任。

### 减轻关键风险(妥协-弹性)
加密签名是保护软件更新系统的必要组成部分。用于创建这些签名的密钥的安全性直接影响系统保护的客户端的安全性。一个安全的软件更新系统不应该天真地**假设私钥总是安全的，而应该预料到当这些密钥被破坏时**，如何尽可能地保护客户端的安全。这是妥协弹性的基本原则。 尽管存在重大妥协，但保护客户安全包括: 
- 快速安全的密钥替换和撤销。
-  对高风险密钥的最低信任度。保持在线或以自动化方式使用的密钥，如果泄露，不应该对客户端构成直接风险。
- 多重密钥使用和签名的阈值/法定人数。


### 完整

确保TUF中的完整性不仅指单个文件，还指整个存储库。很明显，客户端必须验证单个下载的文件是否正确。这并不明显，但对于客户来说，确保他们对存储库的整个视图是正确的仍然非常重要。例如，如果受信任的一方提供两个文件，软件更新系统应该看到两个文件的最新版本，而不仅仅是一个，也不应该看到从未一起提供的两个文件的版本。

### 最新版本 
由于软件更新通常会修复安全漏洞，因此软件更新系统获取这些文件的最新版本非常重要。攻击者可能想欺骗客户端安装过时的软件版本，甚至只是让客户端相信没有可用的更新。 确保新鲜意味着: 
- 永远不要接受比以前看过的文件更旧的文件。
-  识别何时获取更新可能有问题。 

请注意，如果攻击者响应客户端的请求，客户端不可能总是成功更新。但是，客户端应该能够认识到他们无法获得的更新可能存在。

###实施安全 
除了安全设计之外，TUF还致力于防范实施漏洞，包括软件更新系统常见的漏洞。在某些情况下，元数据中包含附加信息有助于实现这一点。例如，知道要下载的目标文件的预期大小允许TUF在检索文件时限制它将下载的数据量。因此，TUF可以安全地抵御无休止的数据攻击(如上所述)。

# 角色和元数据(metadata)
TUF使用角色来定义一方可以执行的一组操作。角色的概念允许TUF只信任由正确指定的一方提供的信息。root角色指示哪些角色可以为哪些项目签名。

角色对元数据进行签名，TUF使用元数据在指定时间创建关于存储库或应用程序状态的可验证记录。因此，客户端可以使用它来决定更新哪些文件。不同的元数据文件提供不同的信息，并将由不同的角色签名。 

签名的元数据文件总是包含过期日期。这确保了过时的元数据将被检测到，并且客户端可以拒绝接受比他们已经看到的旧的元数据。 

所有TUF元数据都使用JSON对象格式的子集。当计算对象的digest时，我们使用规范JSON格式。关于元数据的实现级细节可以在[规范](https://github.com/theupdateframework/specification/blob/master/tuf-spec.md)中找到。 

有四个必需的顶级角色，每个角色都有自己的元数据文件。 必需: 
- root
- Targets
- Snapshot
- Timestamp
- 可选角色：镜像角色

所有角色都可以使用一个或多个密钥，并且需要角色密钥的签名阈值才能信任给定的元数据文件。

## 角色
### Root Role
- root角色将信任委托给系统中使用的所有其他顶级角色信任的特定密钥。
- 框架的客户端必须为每个配置的存储库提供可信的根密钥。
- root角色的私钥必须保持非常安全，因此应该保持脱机状态。如果根密钥少于一个阈值，存储库应该撤销对受损密钥的信任。这可以通过第6.1节(密钥管理和迁移)中介绍的根密钥的正常循环来实现。如果根密钥的阈值被破坏，根密钥应该在带外更新，但是，应该选择阈值，这样这是极不可能的。在不幸的情况下，密钥阈值被破坏，最安全的假设是攻击者已经安装了恶意软件并接管了受影响的机器。因此，让攻击者难以泄露所有离线密钥非常重要，因为从其中安全恢复几乎是不可能的。

### Targets role
目标角色的签名指示哪些目标文件受客户端信任。目标角色签署描述这些文件的元数据，而不是实际的目标文件本身。

此外，目标角色可以将完全或部分信任委托给其他角色。委托信任意味着目标角色指示另一个角色(即信任所需的另一组密钥和阈值)被信任来签署目标文件元数据。部分信任委派是指委派角色仅对委派角色信任的某些目标文件可信。 委托角色可以进一步将信任委托给其他委托角色。

这提供了多级信任委派，其中每个角色可以委派对其信任的目标文件的完全或部分信任。在这些情况下，委托角色仍然是可信的。也就是说，当角色委托信任时，它不会变得不可信。 任何委托都可以随时撤销:委托角色只需要签署不再包含该委托的新元数据。

### Snapshot role
快照角色签署元数据文件，该文件提供关于存储库中所有其他元数据的最新版本的信息(时间戳文件除外，将在下面讨论)。该信息允许客户端知道哪些元数据文件已被更新，并防止混合匹配攻击。

### Timestamp role
为了防止对手重放签名尚未过期的过期签名元数据文件，自动化过程会定期签署包含快照文件哈希的带时间戳的语句。尽管时间戳密钥必须保持在线，但泄露该密钥给客户端带来的风险是最小的。

### Mirrors role
每个存储库都有一个或多个镜像，客户端可以从中下载文件。使用该框架的软件更新系统可以选择对其软件中的镜像信息进行硬编码，或者可以选择使用镜像元数据文件，镜像元数据文件可以可选地由镜像角色签名。 

使用签名镜像列表的重要性取决于应用程序和该应用程序的用户。被骗接触错误的镜像对应用程序的安全风险最小。这是因为框架对存储库信任度很低。

## 元数据
### Root Metadata(root.json)
签名人:root 角色。 

指定其他顶级角色。指定这些角色时，会列出每个角色的**可信密钥**，以及签名角色元数据所需的**最少密钥数**。我们称这个号码为签名门槛。 

[示例](https://raw.githubusercontent.com/theupdateframework/tuf/develop/tests/repository_data/repository/metadata/root.json)

### Targets Metadata (targets.json)
签名人:目标角色。 

目标文件是客户端想要下载的实际文件，例如他们试图获取的软件更新。`targets.json`元数据文件列出了目标文件的哈希和大小。 

该文件可以选择性地定义它委托信任的其他角色，或者指定对于存储库中可用的一些或所有目标文件，要信任的另一个角色。指定委派角色时，其方式类似于根角色指定顶级角色的方式:为每个角色提供**可信密钥**和**签名阈值**。此外，将指定一个或多个全局模式来指示客户端应该信任每个委托角色的目标文件路径。

[示例](https://raw.githubusercontent.com/theupdateframework/tuf/develop/tests/repository_data/repository/metadata/targets.json)

### Delegated Targets Metadata (role1.json)
签名人:委托目标角色。

委派目标角色提供的元数据文件将遵循与顶级目标角色提供的格式完全相同的格式。

当目标角色将信任委托给其他角色时，每个委托的角色将提供一个签名的元数据文件。与顶级元数据的目录结构一样，委托文件相对于给定存储库镜像中可用的元数据的基本网址。 

委派的角色文件位于: 
`/DELEGATED _ ROLE.json` 其中`DELEGATED_ROLE`是在`targets.json`中指定的角色的名称。如果此角色进一步将信任委托给名为另一个ANOTHER_ROLE角色，该角色的签名元数据文件将在以下位置找到: 
`/ANOTHER_ROLE.json`
请参见委派目标元数据[示例](https://raw.githubusercontent.com/theupdateframework/tuf/develop/tests/repository_data/repository/metadata/role1.json)和嵌套委派[示例](https://raw.githubusercontent.com/theupdateframework/tuf/develop/tests/repository_data/repository/metadata/role2.json)。

### Snapshot Metadata (snapshot.json)

签名人:快照角色。 
Snapshot.json元数据文件列出了除timestamp.json以外的所有元数据文件的版本号。该文件确保客户端可以看到存储库中所有文件的一致视图。也就是说，存储库中不同时间存在的元数据文件(以及目标文件)不能被攻击者组合并呈现给客户端。

 请参见快照元数据[示例](https://raw.githubusercontent.com/theupdateframework/tuf/develop/tests/repository_data/repository/metadata/snapshot.json)。
 
### Timestamp Metadata (timestamp.json)
 
签名人:时间戳角色。 
 
`timestamp.json`元数据文件列出了 snapshot.json文件的哈希和大小。这是客户端搜索更新时**第一个也是唯一一个需要下载的文件**。它经常被重新签名，并且具有短的到期日期，因此允许客户端**快速检测他们是否被阻止获取最新的元数据**。在线密钥通常用于定期自动对该文件重新签名。 

`timestamp.json`和`snapshot.json`文件没有合并有几个原因: 
- timestamp.json文件下载非常频繁，因此应该尽可能小，特别是考虑到snapshot.json文件随着委派目标角色的数量成比例地增长。
-  由于**时间戳角色的密钥是在线密钥**，因此风险很高，因此应该使用单独的密钥对`snapshot.json`文件进行签名，以便快照角色的密钥可以保持离线，从而更加安全。 `Timestamp.json`可以被赋予镜像。
 
  请参见时间戳元数据[示例](https://raw.githubusercontent.com/theupdateframework/tuf/develop/tests/repository_data/repository/metadata/timestamp.json)。