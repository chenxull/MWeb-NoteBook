#  基于UDP&boost的C/S程序笔记

## 功能要求

- 客户端实现多线程，同步的方式进行发送数据给服务器端，服务器端接受到信息后进行回显。
- 服务器端监听一个端口，当有多个ip地址进行访问时，用多线程同时处理这些访问请求。
- 四个线程专门用来实现对4个不同网卡数据的接受，主线程用来显示显示处理信息

这个涉及到进程间通信相关的知识，共享内存，消息队列

## 互斥体—解决多线程通信的问题

写过多线程程序的人都知道避免不同线程同时访问共享区域的重要性。如果一个线程要改变共享区域中某个数据，而与此同时另一线程正在读这个数据，那么结果将是未定义的。为了避免这种情况的发生就要使用一些特殊的原始类型和操作。其中最基本的就是互斥体（mutex，mutual exclusion的缩写）。一个互斥体一次只允许一个线程访问共享区。当一个线程想要访问共享区时，首先要做的就是锁住（lock）互斥体。如果其他的线程已经锁住了互斥体，那么就必须先等那个线程将互斥体解锁，这样就保证了同一时刻只有一个线程能访问共享区域。

## 问题

服务器端能否一直开4个线程来处理客户端的多个请求？

或则采用同步客户端，异步服务器端的方式。这方面还需要在研究一下

先实现一个同步的c/s程序，然后在将其改进为异步的

一个电脑4张网卡，客户端程序要求通过这四张网卡将消息发送服务器端。

一台机器有多张网卡，如何实现让不同的线程去监听单个网卡的信息，相当于一种绑定。

## 重新整理一下思路 9.2

整个任务分为二个部分。医用传感器用来检测人体会产生大量的数据，获得这些数据后需要立即传输出去大概数据的总量为29G。是一个圆形的传感器，将这个传感器分为8个部分，每二个部分用一个节点来进行处理这些数据，主要的处理过程就是将这些数据发送出去。 - 每个节点通过8个网卡即对应着8个IP地址将这些数据发送出去，每个IP地址发送614400个包，每个包的大小为1400Bytes。总共发送的数据为614400*1400*8 Bytes
- 在服务器端具体实现的过程，需要创建8个线程，每个线程来处理对应IP的数据传送。每个线程传送614400个包，每个包的大小为1400Bytes

**工作重点**：关键的实现在于客户端的实现，客户端主要用来接收服务端传送过来的数据，并且将这些数据存储在内存当中。 - 在创建线程之前，使用reallocl函数给接收到的数据分配存储的空间，因为服务器端有8个IP地址使用8个线程传送信息过来，所以同样的在客户端，我们也要创建8个线程来接收处理这些数据。数据收来之后直接存储在之前使用reallocl函数分配的空间当中，然后该线程向主线程汇报总共收到多少包，并且通过主线程直接打印出来。 - 具体这些过程的实现细节，需要慢慢的调研一下

## 对我来说，技术的难点：

- 这些包是以什么样的一种形式去传送的，客户端又是如何实现接受的，并且统计出总共接受到多少包。因为客户端在接受时，是通过8个线程分别接受这些包的，这就涉及到线程间的通信，如何统计到总共接受到了多少包。可能使用到的技术（atomic）
- 线程和固定IP的绑定，或者通过创建线程池的方式自动给每个需要处理的IP分配线程来处理？这个需要在网站寻找一下案例

## 9.3 关于使用8个线程处理接受到的数据存储的一些想法

- 创建8个线程，每个线程中绑定不同的IP地址进行发送数据，在服务器端接受这些数据，不过这些接受到的数据是无序的，应为是使用多线程进行传输的，无法确保这些数据到达的顺序。

**上述问题解决方法** - 在调用线程之前使用reallocl函数先创建好整个614400*1400*8Bytes的地址空间大小。然后在手动创建每一个线程，每个线程用来存储数据的首地址可以这么定义&data[i*614400*1400]

## 接下来几天任务安排

- 深入学习一下[Boost::asio库写的客户端和服务端](https://mmoaay.gitbooks.io/boost-asio-cpp-network-programming-chinese/content/Chapter4.html),它的整体架构很不错
- 学习使用boost::thread库，看一些列子，学会使用多线程来处理不同IP发送数据的问题。
- c++存储，内存分配相关的知识。

写代码时可参考的[文件](https://blog.csdn.net/csnd_ayo/article/details/61577634)

## 9.5问题

- 在客户端中，目前是使用线程库来创建8个线程的，但是通过这种方式不太能手动配置使用不同的IP地址来发送信息，接下来可能往下面的方向去寻求解决办法：
- 手动创建8个线程，
- boost库中udp协议中在客户端只要求设置服务器端的地址，和端口号，没有设置自己IP的函数，可能它直接和本机的IP地址绑定，自动的调用网卡去发送数据。现在可能的解决方法是去查一下能否自己设置本机的发送ip