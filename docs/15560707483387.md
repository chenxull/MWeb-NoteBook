# Interface Semantics

值和指针语义的概念在Go随处可见。正如前面的文章所述，语义一致性对于完整性和可读性至关重要。随着代码库的不断增长，它允许开发人员维护一个强大的代码库心智模型。它也有助于最小化错误、副作用和意外行为。

## Introduction
在这篇文章中，我将探索Go中的`interface`如何提供值和指针语义形式。我将教授相关的语言机制，并向你展示这些语义的深度。然后，我将展示当你以一种危险的方式混合这些语义时，编译器是如何试图为你说情的。

## Language Mechanics

接口可以存储自己的值副本(值语义)，一个 value 通过和` interface`共享存储值的地址副本。这就是接口的值/指针语义的来源。这段代码向您展示了这些语义是如何工作的


```
01 package main
02
03 import "fmt"
04
05 type printer interface {
06     print()
07 }
08
09 type user struct {
10     name string
11 }
12
13 func (u user) print() {
14     fmt.Println("User Name:", u.name)
15 }
16
17 func main() {
18     u := user{"Bill"}
19
20     entities := []printer{
21         u,
22         &u,
23     }
24
25     u.name = "Bill_CHG"
26
27     for _, e := range entities {
28         e.print()
29     }
30 }
```
代码在第05行声明了一个名为`printer`的接口，其中一个行为称为`print`。然后，在第09行声明一个名为`user`的具体类型，它在第13行使用`值语义`实现打印机接口。


在`main`函数中，在第18行创建了一个用户值，并用名称Bill初始化。然后在第20行，声明并初始化一片`printer`接口值。通过在索引0内部存储用户值的副本，初始化的切片正在第21行使用**值语义**。然后在第22行，**指针语义**被用来在索引1中存储用户地址的副本。

在第25行，用户值被改变，最后在第27行，切片重复显示存储在相应接口值内的每个用户的名称。

下面的图显示了如何存在两个不同的用户值。索引0引用第18行声明的原始用户值的副本(值语义)，索引1引用第18行声明的原始值(指针语义)。
![](https://www.ardanlabs.com/images/goinggo/85_figure1.png)

最终输出显示，只有索引1(使用指针语义的接口值)看到了变化。

```
User Name: Bill
User Name: Bill_CHG
```

请记住，在我要求你阅读的其他帖子中，选择一个语义而不是另一个语义是在你声明或使用类型时做出的决定。您希望尽可能保持语义的一致性。我们刚刚经历的这个例子向您展示了如何将不同的语义应用于接口。

## Method Sets
在超越**接口**提供的值/指针语义之前，检查方法集的规则很重要。**方法集规则有助于描述给定类型的数据何时可以存储在接口内部**。这些规则都是关于完整性的。

![](https://www.ardanlabs.com/images/goinggo/85_figure2.png)

规则声明:
- 当使用值接收器(值语义)实现接口时，**值和地址的副本**可以存储在接口内。
- 然而，当使用指针接收器(指针语义)实现接口时，只能存储地址的副本。

这引出了一个问题——当使用指针语义时，为什么不允许值的副本存储在接口中？**答案是两部分的完整性问题。**

### 原因一
**首先**，你不能保证每个值都是可寻址的。如果不能获取一个值的地址，它就不能被共享，因此不能使用指针接收器方法。


下一个例子展示了如何不能总是在Go中获取值的地址。

```
01 package main
02
03 import "fmt"
04
05 type notifier interface {
06     notify()
07 }
08
09 type duration int
10
11 func (d *duration) notify() {
12     fmt.Println("Sending Notification in", *d)
13 }
14
15 func main() {
16     duration(42).notify()
17 }
```
上述代码声明了一个名为`duration`的类型，并在第11行使用**指针**语义实现了`notifier`接口。在第16行的主函数中，值42被转换为类型`duration`的值，然后调用`notify`方法。对`notify`方法的调用会导致以下编译器错误:

```
main.go:16: cannot call pointer method on duration(42)
main.go:16: cannot take the address of duration(42)
```


因为数字在Go中是常数，所以它们**只在编译时存在，没有地址**。`notify`方法要求共享`duration`值，这是不可能的。这解释了为什么使用指针语义实现的接口只允许存储地址副本的第一个原因。**编译器不能假设它可以为使用指针语义实现接口的类型，获取任何给定值的地址。**

### 原因二
**第二个原因同样重要**，我认为这是**完整性**的巨大胜利。再次查看指针语义的方法集规则。
![](https://www.ardanlabs.com/images/goinggo/85_figure3.png)

如果使用**指针语义实现接口**，规则的这一部分将阻止您在接口中存储值(值语义)的副本。该规则强化了这样一种观点，即如果您将语义从指针更改为值，它就越过了一条危险的线。如果**您使用指针接收器实现接口，则只能与接口共享值，而不能存储实际值**。你永远不能假设指针指向的任何**值的副本**都是安全的。这就是为什么指针语义的“store value”框是红色的。 

再次查看方法集规则的值语义:
![](https://www.ardanlabs.com/images/goinggo/85_figure4.png)


如果使用值语义实现接口，规则的这一部分允许您在**接口内存储值**(值语义)和**地址**(指针语义)的**副本**。该规则支持这样的想法，即如果将语义从值更改为指针，它可能是安全的。然而，有一句话与这个想法有关。**混合语义是一个一致性问题**，必须作为一个例外来执行。**一致性**是一切，混合语义会在代码中产生意想不到的副作用。这就是为什么值语义的“存储指针”框是黄色的。 **不推荐在值接受者中存储指针地址的副本**

## Interfaces Are Valueless
您可能会想，**因为接口值的第二个字总是存储在其中的具体值的地址，所以总会有一个地址可以用来调用指针接收器方法**。那么，当指针语义被用来实现接口时，为什么要限制存储一个值呢？

接口值的第二个字存储地址这一事实无关紧要。如果您在定义方法集规则时考虑这个实现细节，那么您实际上是允许实现细节潜入规范中。从规范的角度来看，任何东西是如何实现的都是无关紧要的，因为实现总是在变化。

我希望您理解，从我们的代码角度来看，接口值是“valueless”。接口值本身没有什么具体的东西。

下一个例子提供了帮助解释这一点的代码。


```
01 package main
02
03 import "fmt"
04
05 type notifier interface {
06     notify()
07 }
08
09 type duration int
10
11 func (d duration) notify() {
12     fmt.Println("Sending Notification in", d)
13 }
14
15 func main() {
16     var n notifier
17     n = duration(42)
18     n.notify()
19 }
```
在第16行的中，声明了一个名为n的接口类型`notifier`程序变量，并将其设置为零值，即`nil`接口值。变量n是`valueless`的，直到第17行接口值才具有任何具体状态。


唯一使接口具体化的是存储在其中的数据。方法集规则根据方法集的实现方式(使用值或指针语义)定义可以存储哪些数据(值或地址)。完整性和语义是规则的定义。所有这些实际上是如何完成的是一个实现细节。

当比较两个接口值时，比较的是它们内部的**具体数据，而不是接口值本身**。


```
01 package main
02
03 import "fmt"
04
05 type errorString struct {
06     s string
07 }
08
09 func (e errorString) Error() string {
10     return e.s
11 }
12
13 func New(text string) error {
14     return errorString{text}
15 }
16
17 var ErrBadRequest = New("Bad Request")
18
19 func main() {
20     err := webCall()
21     if err == ErrBadRequest {
22         fmt.Println("Interface Values MATCH")
23     }
24 }
25
27 func webCall() error {
28     return New("Bad Request")
29 }
```
在第05行到第15行，我从错误包中复制了默认`error`类型的实现，只做了一个更改。我在第13行实现的新函数是使用**值语义**，而不是指针语义。它在返回的错误接口值中存储一个**errorString**值，而不是它的地址。

在第17行，为“Bad Request”错误声明了一个`error`接口变量。跳到第27行，`webCall`函数返回一个新的`error`接口值，并带有相同的消息“Bad Request”。然后在第19行的主函数中，调用webCall函数，并将返回的错误接口值与错误接口变量进行比较。

当您运行该程序时，您将看到两个错误接口值是等效的。

```
Interface Values MATCH

```

## 小结

这篇文章提供了另一个例子，说明了**值和指针语义**如何在Go中编写代码中发挥重要作用。**接口**可以存储自己的值副本(值语义)或值地址副本(指针语义)。我想展示方法集规则是如何通过不允许从**指针到值的语义变化**来提供完整性检查的。这助长了这样一种观点，即指针指向的值的复制是不安全（ it is not safe to make a copy of the value that is pointed to by a pointer. ）。语义的这种混合必须认真对待。 

当您继续在Go中编写代码时，请查看您为任何给定类型使用的语义。在代码审查期间，寻找给定类型的数据和违反它的问题代码在语义上的一致性。每一条规则都有例外，但我想确保例外是作为一种有意识的选择而发生的。

**为什么说在指针接受者方法中，指针指向的值的复制时不安全的？**
因为无法确保每一个值的地址都是可寻址的，如果你不能获取一个值的地址，它就不能被共享，因此不能使用指针接收器方法。比如说在 go 中，数字常量只在**编译期存在，其是没有地址的**。还有一点原因就是` interface`的规则做了强制要求
