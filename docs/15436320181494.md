# 并发编程


##并发程序与并行程序
并发程序指的是可以被同时发起执行的程序，并行程序则被设计成可以在并行的硬件上执行的并发程序。

并发程序代表了所有可以实现并发行为的程序，它是一个比较宽泛的概念，其中包括了并行程序。

### 并发程序的不确定性

串行程序中所有代码的先后顺序都是固定的，而并发程序中只有部分代码是有序的。其中的一些代码的执行顺序并没有明确指定，这一特性就是不确定性，这导致并发程序每次运行的代码执行路径都是不同的。

### 并发程序内部的交互

并发程序内部会被划分为多个部分，每个部分都可以看做是一个串行程序。在这些串行程序之间，可能存在交互的需求。比如，多个串行程序可以要对一个共享的资源访问；它们之间需要传递一些数据，在这些情况下我们需要协调它们的执行，这就涉及到同步。同步的作用就是避免在并发访问共享资源时可能发生的冲突，以及确保数据的有序传输。

根据同步的原则，程序如果想使用一个共享资源，就必须先申请对该资源并获取其访问权，不在使用该资源时，应该放弃对该资源的访问权。一个程序对资源的请求不应该导致其他正在访问该资源的程序中断，应该等待。

协调这种内部通讯的方式不只同步这一种，也可以使用异步的方式对通信进行管理。这种方式使得数据可以不加延时的发送给数据接收方，通过通信缓存的数据结构实现这个设计。通信缓存是一种特殊的共享资源，可以同时被多个程序使用。

### 多进程编程

在多进程程序中，如果多个进程之间需要协作完成任务，那么进程间通信的方式就是重点需要考虑的事项之一。这种同通信叫做IPC（Inter-Process Communication），不同版本unix系统所支持的IPC都不一样，有很多标准。

在Linux中可以使用的IPC方法有多种，从处理机制的角度看，可分为三大类：

- 基于通信的IPC方法
    - 数据传送为手段的IPC方法：管道(pipe)和消息队列(message queue)。管道用来传送字节流，消息队列传送结构化的消息对象
    - 共享内存为手段的IPC方法：共享内存区(shared memory）最快的一种IPC方法
- 基于信号的IPC方法：操作系统的信号（signal）机制，它是唯一一种异步IPC方法
- 基于同步的IPC方法：最重要的就是信号量(semaphore)

GO支持的IPC方法有管道，信号和socket


## 进程的一些概念

### 进程的状态

可能的状态有6个

- 可运行状态(TASK_RUNNING ,R)：它立刻要或正在CPU上运行，不过运行的时机是不确定的，由进程调度器来决定。
- 可中断的睡眠状态：当进程正在等待某个时间（网络连接或信号量）到来时，会进入此状态。这样的进程会被放入对应事件的等待队列中，当事件发生时，对应的等待队列中的一个或多个进程就会被唤醒
- 不可中断的睡眠状态：此状态的进程不会对任何信号做出相应。更准确来说，发送给出状态的进程的信号直到它从该状态转出去才会被传递过去。处于此状态的进程通常在等待一个特殊事件，比如等待同步I/O操作完成
- 暂停状态或跟踪状态: 例如，使用GDB在某个程序中设置一个端点，而后对应的进程在运行到该断点处就会听下来，这时就处于跟踪状态，跟踪状态和暂停状态很类似，但是向处于跟踪状态的进程发送SIGCONT信号不能使她恢复，只有当调试进程进行了相应的系统调用或者退出后，才能恢复
- 僵尸状态：进程已经结束运行，占用的大部分资源已经被回收，还要部分信息未被删除。
- 退出状态

![](https://ws2.sinaimg.cn/large/006tNbRwly1fxr3cfrz3nj316o0u0hdt.jpg)

### 进程的系统调用

内核空间和用户空间

![](https://ws1.sinaimg.cn/large/006tNbRwly1fxr3tx73hmj30r00lo7k3.jpg)

用户进程无法直接访问内核空间，也无法随意指定内核做一些事，但是为了使用户进程能够使用操作系统更底层的功能，内核会暴露出一些接口供用户进程使用。这些接口是用户进程使用内核功能的唯一方式。用户进程使用这些接口的行为成为系统调用。

虽然系统调用也是由函数呈现的，但是它与普通的函数还是有很明显的区别。系统调用是想内核空间发出一个明确请求，而普通函数只是定义了如何获取一个给定的服务。更重要的是，系统调用会导致内核空间中数据的存取和指令的执行，而普通函数却只能在用户空间中有所作为。

#### 内核态和用户态

为了保证操作系统的稳定和安全，内核根据CPU提供的，可以让进程驻留的特权级别建立了二个特权状态-内核态和用户态。大部分时间，CPU处于用户态，这时只能对用户空间进行访问，当用户进程发出一个系统调用的时候，内核会把CPU从用户态切换到内核态，然后让CPU直行对应的内核函数。 执行流程大致如下：

![](https://ws4.sinaimg.cn/large/006tNbRwly1fxr45ojj9pj31830u0hdt.jpg)

封装例程和系统调用是一一对应的，这个就是内核暴露给用户进程的接口。


## 关于同步

只要多个进程同时对一个资源进行访问，就可能互相干扰，这称为竞态条件。

执行过程不能中断的操作称为原子操作，而只能被串行化访问或执行的某个资源或某段代码称为临界区(critical section)。所有的系统调用都是原子操作，不用担心其被中断。

原子操作必须由一个单一汇编指令表示，需要芯片级别的支持。这使得原子操作可以做到绝对的并发安全，并且比其他的同步机制快很多。原子操作只适合细粒度的简单操作。

相比于原子操作，让串行化执行的若干代码形成临界区更加通用，保证只有一个进程或者线程在临界区之类的做法称为-互斥。        
 

## 管道

管道是一种半双工的通信方式，只能用于父进程与子进程以及同先祖的子进程之间的通信。对于管道GO支持，通过代码包os/exec中的API，可以执行操作系统命令并在此基础之上建立管道。

管道分为二种类型，一种类型是无名管道用于具有亲缘关系的进程之间；宁一种是有名管道，或者叫FIFO管道，它是一种存在于文件系统的管道，可以被二个没有任何亲缘关系的进程进行访问。有名管道一般通过mkfifo()函数来建立

``` cmd :=exec.Command("echo","-n","sdadad") ```

在exec.Cmd类型之上有个Start方法，可以使用它启动命令

```
 if err := cmd.Start();err!=nil{
    return 
    }
```
为了创建一个能获得此命令的输出管道，需要使用```cmd.StdoutPipe()``` 此方法返回的类型是```io.ReadCloser```是扩展了```io.Reader```接口的接口类型，并定义了可关闭的数据读取行为。

```ps aux | grep apipe```
上面这种管道称为**匿名管道**，与此相对的是命名管道，任何进程都可以通过命名管道交换数据，命名管道以文件的形式存在于文件系统中。

在Go的标准代码库os中，含有这种命名管道的API ，如下:

```
reader,writer,err := os.Pipe()
```

os.Pipe会返回三个值，第一个是管道的输出端```*os.File```,第二个是管道的输入端 ```*os.File```
它们共同形成了数据传递的渠道。

由于通过os.Pipe函数生成的管道在底层是由系统级别的管道来支持，使用时需要注意操作系统的对管道的限制。例如，匿名管道会在管道缓冲区被写满之后使写数据的进程阻塞；命名管道会在其中一端未就绪前阻塞另一端的进程 。

go的标准代码包io提供了一个基于内存的有原子性操作保证的管道（内存管道），在内存管道的内部，充分的使用了sync代码包中的API，从根本上保证了相关操作的原子性，可以放心的并发写入和读取数据。



## 信号

进程相应信号的方式有3种：忽略，捕捉和执行默认操作。Linux对每一个标准信号的有默认的操作方式，默认的操作方式一定会是一下操作之一：终止进程，忽略该信号，终止进程并保存内存信息，停止进程，恢复进程



