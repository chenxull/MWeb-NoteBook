# Part III - Concurrency
这篇博文关注于并发

##  简介
当我在解决一个问题时，特别是如果这是一个新问题，我最初不会考虑并发性是否合适。我首先寻找顺序解决方案，并确保它是有效的。然后在可读性和技术回顾之后，我将开始问并发性是否合理和实用。有时很明显并发是一个很好的选择，而其他时候就不那么清楚了。

在本系列的第一部分，我解释了操作系统调度器的机制和语义，我认为如果您打算编写多线程代码，这些机制和语义是很重要的。在第二部分中，我解释了Go调度器的语义，我认为这对理解如何在Go中编写并发代码很重要。在这篇文章中，我将开始把操作系统和Go调度器的机制和语义结合在一起，以便更深入地理解**什么是并发性，什么不是并发性。**

这篇文章的目的如下：
- 提供关于语义的指导，您必须考虑这些语义来确定工作负载是否适合使用并发性。
- 向您展示不同类型的工作负载如何改变语义，从而改变您想要做出的工程决策。

##  What is Concurrency
并发意味着“无序”执行。获取一组不会按顺序执行的指令，并找到一种方法无序执行它们，但仍然产生相同的结果。对于你面前的问题，很明显无序的执行会增加价值。当我说价值时，我的意思是为复杂性成本增加足够的性能增益。根据您的问题，无序执行可能是不可能的，甚至是没有意义的。


理解并发不同于并行也很重要。并行意味着同时执行两条或更多条指令。这与并发是不同的概念。只有当您至少有2个操作系统和硬件线程可用，并且您至少有2个Goroutiness时，并行才是可能的，每个Goroutine在每个操作系统/硬件线程上独立执行指令。

![](https://www.ardanlabs.com/images/goinggo/96_figure1.png)
上图中可以看到两个逻辑处理器(P)的示意图，每个处理器的独立操作系统线程(M)连接到机器上的独立硬件线程(核心)。您可以看到两个Goroutine(G1和G2)并行执行，同时在各自的操作系统/硬件线程上执行它们的指令。在每个逻辑处理器中，三个Goroutine轮流共享各自的操作系统线程。所有这些Goroutines都是并发运行的，以不特定的顺序执行它们的指令，并在操作系统线程上共享时间。

问题是，有时利用并行性而没有并行性实际上会降低吞吐量。同样有趣的是，有时利用并行性的并发性并不能给你带来比你想象的更大的性能提升。

##  Workloads
你怎么知道什么时候无序执行是可能的或有意义的？了解您的问题正在处理的工作量类型是一个很好的开始。在考虑并发性时，有两种类型的工作负载非常重要
- CPU-Bound:这是一个永远不会造成Goroutine自然进出等待状态的工作负载。这是一项不断进行计算的工作。将圆周率计算到第n位的线程将是受中央处理器限制的。
- IO-Bound:这是一个导致Goroutine自然进入等待状态的工作负荷。这项工作包括请求**通过网络访问资源**，或者对**操作系统进行系统调用**，或者**等待事件发生**。需要读取文件的Goroutine将被输入输出绑定。我将包括同步事件(互斥体，原子)，这将导致Goroutine等待作为这个类别的一部分。

对于 CPU-Bound的工作负载，您需要并行性来利用并发性。单个操作系统/硬件线程处理多个Goroutines效率不高，因为Goroutines不会作为其工作负载的一部分移入和移出等待状态。拥有比操作系统/硬件线程更多的Goroutine可能会降低工作负载的执行速度，因为在操作系统线程上来回移动Goroutine需要等待时间。上下文切换正在为您的工作负载创建一个“停止世界”事件，因为在切换过程中，您的工作负载都不会被执行。

对于 IO-Bound的工作负载，您不需要并行来使用并发性。单个操作系统/硬件线程可以高效地处理多个Goroutine，因为Goroutine作为其工作负载的一部分自然地移入和移出等待状态。拥有比操作系统/硬件线程更多的Goroutines可以加快工作负载的执行，因为将Goroutines移进移出操作系统线程的延迟成本不会产生“停止世界”事件。您的工作负载自然会停止，这允许不同的Goroutines有效地利用相同的操作系统/硬件线程，而不是让操作系统/硬件线程闲置。

初步总结**cpu 绑定的事件不适合用Goroutines，IO绑定的事件适合用Goroutines**

您如何知道每个硬件线程有多少个Goroutines提供最佳吞吐量？Goroutines太少，你就有更多空闲时间。太多的Goroutines和你有更多的上下文切换等待时间。这是你需要考虑的事情，但超出了这篇文章的范围。

目前，重要的是回顾一些代码，以巩固您识别工作负载何时可以利用并发性、何时不能以及是否需要并行性的能力。


## 例子 adding numbers

我们不需要复杂的代码来可视化和理解这些语义。请看下面名为add的函数，它对整数集合求和。

```
36 func add(numbers []int) int {
37     var v int
38     for _, n := range numbers {
39         v += n
40     }
41     return v
42 }
```
第36行，声明了一个名为add的函数，该函数获取整数集合并返回集合的总和。它从第37行开始，声明包含总和的v变量。然后在第38行，函数线性遍历集合，并将每个数字加到第39行的当前和上。最后在第41行，函数将最终的和返回给调用者。

问题:添加功能是适合无序执行的工作负载吗？我相信答案是肯定的。整数集合可以分解成更小的列表，这些列表可以同时处理。一旦所有较小的列表相加，这组和可以加在一起产生与顺序版本相同的答案。

然而，我想到了另一个问题。为了获得最佳吞吐量，应该独立创建和处理多少个较小的列表？要回答这个问题，您必须知道正在执行哪种工作负载添加。加法函数执行的是 CPU-Bound的工作负载，因为算法执行的是纯数学运算，它不会导致goroutine进入自然等待状态。这意味**着每个操作系统/硬件线程使用一个Goroutine是获得良好吞吐量所需要的**。

下面是我的add并发版本。

```
func addConcurrent(goroutines int, numbers []int) int {
45     var v int64
46     totalNumbers := len(numbers)
47     lastGoroutine := goroutines - 1
48     stride := totalNumbers / goroutines
49
50     var wg sync.WaitGroup
51     wg.Add(goroutines)
52
53     for g := 0; g < goroutines; g++ {
54         go func(g int) {
55             start := g * stride
56             end := start + stride
57             if g == lastGoroutine {
58                 end = totalNumbers
59             }
60
61             var lv int
62             for _, n := range numbers[start:end] {
63                 lv += n
64             }
65
66             atomic.AddInt64(&v, int64(lv))
67             wg.Done()
68         }(g)
69     }
70
71     wg.Wait()
72
73     return int(v)
74 }
```

并发版本肯定比顺序版本更复杂，但是这种复杂性值得吗？回答这个问题的最好方法是创建一个基准。对于这些基准测试，我已经在关闭垃圾收集器的情况下收集了1000万个数据。有一个使用添加函数的顺序版本和一个使用添加并发函数的并发版本。


```
func BenchmarkSequential(b *testing.B) {
    for i := 0; i < b.N; i++ {
        add(numbers)
    }
}

func BenchmarkConcurrent(b *testing.B) {
    for i := 0; i < b.N; i++ {
        addConcurrent(runtime.NumCPU(), numbers)
    }
}
```

上述展示了基准函数。以下是当所有goroutine只有一个操作系统/硬件线程可用时的结果。顺序版本使用1个Goroutine，并发版本使用运行时。在我的机器上有8个Goroutine。在这种情况下，并发版本利用了无并行性的并发性。


```
oos: darwin
goarch: amd64
pkg: test/day423/1
BenchmarkSequential 	    1000	   5873376 ns/op
BenchmarkConcurrent 	    1000	   5819549 ns/op
PASS
ok  	test/day423/1	15.582s
```
上述基准测试显示，当所有Goroutine只有一个操作系统/硬件线程可用时，顺序版本比并发版本快大约10%到13%。这是我所期望的，因为并发版本在单个操作系统线程上有上下文切换的开销，并且管理Goroutines。

以下是每个Goroutine都有一个单独的操作系统/硬件线程时的结果。顺序版本使用1个Goroutine，并发版本使用运行时。在我的机器上有8个Goroutine。在这种情况下，并发版本利用了并行性。


```
goos: darwin
goarch: amd64
pkg: test/day423/1
BenchmarkSequential-8   	    1000	   5588097 ns/op
BenchmarkConcurrent-8   	    1000	   3266342 ns/op
PASS
ok  	test/day423/1	12.532s
```

上述基准测试显示，当每个Goroutine都有单独的操作系统/硬件线程可用时，并发版本比顺序版本快大约41%到43%。这是我所期望的，因为所有的Goroutine现在都并行运行，八个Goroutine同时执行它们的并行工作。

##   小结
这篇文章的目的是提供关于语义的指导，您必须考虑这些语义来确定工作负载是否适合使用并发性。我试图提供不同类型的算法和工作负载的例子，以便您可以看到语义上的差异以及需要考虑的不同工程决策。


您可以清楚地看到，对于 IO-Bound 的工作负载，并行性对于大幅提升性能的帮助不大。这与您在面向 CPU-Bound 工作中看到的正好相反。当涉及到像冒泡排序这样的算法时，并发性的使用会增加复杂性，而没有任何真正的性能优势。重要的是确定您的工作负载是否适合并发，然后确定您必须使用正确语义的工作负载类型。