# HTTPS

HTTP 有以下安全性问题：

使用明文进行通信，内容可能会被窃听；
不验证通信方的身份，通信方的身份有可能遭遇伪装；
无法证明报文的完整性，报文有可能遭篡改。

https 采用混合加密，使用非对称密钥加密用于传输，对称密钥 来保证传输过程的安全性，之后使用对称密钥加密来进行通信来保证通信过程的效率。

## 认证

通过使用 证书 来对通信方进行认证。

## http2.0

HTTP/1.x 实现简单是以牺牲性能为代价的：

- 客户端需要使用**多个连接**才能实现并发和缩短延迟；
- 不会**压缩请求和响应首部**，从而导致不必要的网络流量
- 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。



### 二进制分帧层
 HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。

![](https://github.com/CyC2018/CS-Notes/blob/master/notes/pics/86e6a91d-a285-447a-9345-c5484b8d0c47.png)

在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。

- 一个数据流（Stream）都有一个**唯一标识符**和**可选的优先级信息**，用于承载双向信息。
- 消息（Message）是与**逻辑请求或响应对应的完整的一系列帧。**
- 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。

### 服务端推送

HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。

### 首部压缩
HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。

HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。

不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。

## http1.1

- 默认是长连接
- 支持流水
- 支持同时打开多个 tcp 连接
- 支持虚拟主机

