# golang 面试问题整理

**1.struct 能否进行比较**
在规范中定义：如果两个变量可比较，那么他们必然是可赋值的，要么左边变量可赋值给右边变量，要么右边变量可赋值给左边变量。反之则不一定，即可赋值的变量，不一定可比较，比如前面提到的map类型变量。

所以两个可比较的变量，也必须满足他们或者**类型相同**，或者他们的**底层类型**(underlying types)相同。

对于 struct 来说有二条规则：
1. 从所有比较操作继承下来的规则，**即两个变量必须是可赋值的**
2. 针对struct本身的规则，**即struct的所有域必须都是可比较的；注意这里并不管struct本身的定义类型。**

---

**2.select可以用来干什么**
select用来在多个channel上执行**多路复用**操作，select的语义和规则如下：
1. select**只能**用来操作channel, 读或者写;
2. select中可以有多个case分支，还可以有一个default分支。如果select时没有一个case处于ready状态，那么就会执行default分支;
3. 如果多个case分支同时处于ready状态，那么select会**随机**选择一个分支执行;
4. 如果select代码块中没有任何分支，那么**当前协程便会阻塞**。因此可以使用select {}来永久地阻塞当前协程。

---
**3.defer 的使用**
让函数或语句可以在当前函数执行完毕后（包括通过return正常结束或者panic导致的异常结束）执行。

defer语句通常用于一些成对操作的场景：**打开连接/关闭连接；加锁/释放锁；打开文件/关闭文件等**。

defer在一些**需要回收资源的场景非常有用**，可以很方便地在函数结束前做一些清理操作。在打开资源语句的下一行，直接一句defer就可以在函数返回前关闭资源，可谓相当优雅。

**原理：**每次defer语句执行的时候，会把函数“压栈”，函数参数会被拷贝下来；当外层函数（非代码块，如一个for循环）退出时，defer函数按照定义的逆序执行；如果defer执行的函数为nil, 那么会在最终调用函数的产生panic.

在defer函数定义时，对外部变量的引用是有两种方式的，分别是作为函数参数和作为闭包引用。作为函数参数，则在defer定义时就把值传递给defer，并被cache起来；作为闭包引用的话，则会在defer函数真正调用时根据整个上下文确定当前的值。

**defer函数定义的时候，参数就已经复制进去了**

---

**4.闭包**
闭包是由**函数**及其**相关引用环境**组合而成的实题：
```
闭包=函数+引用环境
```

一般的函数都有函数名，但是匿名函数就没有。匿名函数不能独立存在，但可以直接调用或者赋值于某个变量。**匿名函数也被称为闭包，一个闭包继承了函数声明时的作用域。**在Golang中，**所有的匿名函数都是闭包**。

有个不太恰当的例子，可以把闭包看成是一个类，一个闭包函数调用就是实例化一个类。闭包在运行时可以有多个实例，它会将同一个作用域里的变量和常量捕获下来，无论闭包在什么地方被调用（实例化）时，都可以使用这些变量和常量。而且，闭包捕获的变量和常量是引用传递，不是值传递。

--- 

**5.主协程如何等待其余协程退出之后再退出？**

当主协程退出时，并不会等待其他其他协程(后面称为工作协程)执行完毕。工作协程可能正在执行某个事务，主协程退出后，这个事务也就中断了。因此在主协程收到退出信号时，应该给工作协程发送退出信号，然后工作协程都退出后主协程再退出。工作协程在检测到退出信号后，开始释放占有的资源然后退出，这个操作不应该间隔太久，否则在主协程收到退出信号后因为要等待工作协程的退出，导致进程迟迟不会结束。主协程给工作协程发送退出信号可以使用前文中介绍的用 channel 当成信号量的方式。后文中将介绍更通用的使用标准库中的 context.Context 来管理工作协程生命期的方式.

Golang中实现控制并发的方式，大致可分成以下三类：

全局共享变量
channel + select
Context + select

---

**6.Context包的用途**
网络请求Request，每个Request都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的goroutine。这就形成了一棵goroutine树，所以我们需要一种可以跟踪goroutine的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的Context，称之为上下文非常贴切，它就是goroutine的上下文。

总结一下，context包主要有以下两个用途：

1. 优雅地控制协程树的结束;
2. 传递一些元数据.