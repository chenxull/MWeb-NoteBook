# 为什么我们需要 Pod

用来解决**进程和进程组**关系,许多实际中的应用程序都是由多个进程共同作用来提供服务的 这就有了组的概念。 如果没有 pod 多个相关的容器化应用部署起来会很不方便。

这本质上受限于容器的“单进程模型”,容器的“单进程模型”，并不是指容器里只能运行“一个”进程，而是指容器没有管理多个进程的能力。这是因为容器里 PID=1 的进程就是应用本身，其他的进程都是这个 PID=1 进程的子进程。可是，用户编写的应用，并不能够像正常操作系统里的 init 进程或者 systemd 那样拥有进程管理的功能。比如，你的应用是一个 Java Web 程序（PID=1），然后你执行 docker exec 在后台启动了一个 Nginx 进程（PID=3）。可是，当这个 Nginx 进程异常退出的时候，你该怎么知道呢？这个进程退出后的垃圾收集工作，又应该由谁去做呢？

在引入了 pod 之后，多个相关的软件容器化之后，可以放在同一个 pod 中对外提供服务。
## 什么样的容器适合放在同一个 pod 中

容器之间紧密协作，可以称为“超亲密关系”。这些具有“超亲密关系”容器的典型特征包括但不限于：
1. 互相之间会发生之间的文件交换
2. 使用 localhost 或者 socket 文件进行本地通信
3. 会发生非常频繁的远程调用
4. 需要共享某些 namespace


## pod 更重要的意义


如果引入 pod 只是为了解决调度问题，在 kubernetes 系统中肯定可以在调度器层面解决这个问题。 

其实 pod 更为重要的一个意义就是：**容器设计模式**

### Pod 的实现原理
**首先,关于 Pod最重要的事实是:它只是一个逻辑概念**

也就是说,k8s 真正处理的,还是宿主机操作系统上 Linux 容器的 Namespace 和 Cgroups,并不存在一个所谓的**pod的边界或则隔离环境**

那么 pod 又是怎么被"创建"出来的呢?

**pod,其实是一组共享了某些资源的容器**,具体来说:**pod 里的所有容器,共享的同一个 Network Nampspace,并且可以声明共享同一个 Volume**

这和使用 docker 命令是二个容器共享不一样,比如说启动容器 B 就必须启动容器 A,这样 pod 里的多个容器就不是对等关系了,而是一种拓扑关系.

所以在 kubernetes中,`Pod`的实现需要使用一个**中间容器**,这个容器叫做 Infra 容器. 在这个 pod 中,Infra 容器永远都是第一个被创建的容器,
其他用户自定义的容器,则通过` Join Network Namespace`的方式，与 Infra 容器关联在一起. 可以用下图来表示
![](https://static001.geekbang.org/resource/image/8c/cf/8c016391b4b17923f38547c498e434cf.png)

Infra 容器占用极少的资源,使用了一种特殊的镜像:`k8s.gcr.io/pause`,这个镜像时用汇编写的 永远处于暂停状态,解压后大小也只有 100_200kb

这样pod 中容器之间就形成了对等的关系.

而对于同一个 Pod 里面的所有用户容器来说，它们的进出流量，也可以认为都是通过 Infra 容器完成的。这一点很重要，**因为将来如果你要为 Kubernetes 开发一个网络插件时，应该重点考虑的是如何配置这个 Pod 的 Network Namespace，而不是每一个用户容器如何使用你的网络配置，这是没有意义的**

想开发网络插件,关键是关注**infra 容器的 Network Namespace**


--- 

明白了 Pod 的实现原理后，我们再来讨论“容器设计模式”，就容易多了。

Pod 这种“超亲密关系”容器的设计思想，实际上就是希望，当用户想在一个容器里跑多个功能并不相关的应用时，应该优先考虑它们是不是更应该被描述成一个 Pod 里的多个容器。

### 容器设计模式

**sidecar**:我们可以在 pod 中,启动一个辅助容器,来完成一些独立于主进程(主容器)之外的工作

**Pod 的一个重要特性,所有的容器都共享同一个 Network Namespace**,这中设计,使得很多与 pod 网络相关的配置和管理,也都可以交给 sidecar 完成,无需干涉用户的容器.   istio 就是这样做的。