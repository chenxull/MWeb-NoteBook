# CAS 操作

独占锁是一种悲观锁，会导致其他所有未持有锁的线程阻塞，而等待持有锁的线程释放锁。乐观锁，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就去重试，直到成功为止。**乐观锁的机制就会 CAS**


##         1.CAS（Compare And Set）

CAS是解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——**内存位置（V）、预期原值（A）、新值(B)**。如果内存位置与预期原值匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。**CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。**

  CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题：ABA问题、循环时间长开销大、只能保证一个共享变量的原子操作。
    **ABA问题:**因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 从Java1.5开始JDK的 atomic包里提供了一个类`AtomicStampedReference` 来解决ABA问题。这个类的 compareAndSet方法作用是首先检查**当前引用是否等于预期引用，并且当前标志是否等于预期标志**，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。