# 第七章


## 3 final 修饰符

final 具有不可改变的含义 ，可修饰非抽象类，非抽象成员和变量：
- final 修饰的类不能被继承，没有子类
- final 修饰的方法不能被子类的方法覆盖
- final 修饰的变量表示常量，只能被赋值一次

### 3.1 final 类
把类定义为 final 类型，使其不能被继承
- 不是专门为继承而设计的类，类本身的方法之间有复杂的调用关系
- 处于安全的原因，类的实现细节不允许有任何改动
- 在创建对象模型时，确信这个类不会在被扩展

### 3.2 final 方法

不可被子类覆盖

### 3.3 final 变量

- final 修饰符可以修饰静态，实例，局部变量
- final 类型的变量都必须显示初始化
- 只能赋值一次
- final 修饰引用类型的变量，**该变量只能始终引用一个对象，但可以改变对象的内容**


## 4 static 修饰符

可以修饰 类的成员变量，成员方法和代码块
- 修饰成员变量表示静态变量，可以直接通过类名来访问
- 修饰成员方法表示静态方法
- 修饰代码块表示静态代码块，当 jvm 加载类时，就会执行该代码块

static 修饰的东西，归某个类所有，不依赖类特定的实例，被类所有的实例所共享。只要类被加载，jvm 就可以根据类名在运行时数据区的方法区定位到。


### 4.1 static 变量

- 静态变量在内存中只有一个备份
- 实例变量，每创建一个实例，就会为实例变量分配一次内存，可有多个备份，互不影响。

### 4.2 static 方法
静态方法和静态变量一个，不需要创建类的实例，直接通过类名来访问

**1 静态方法可访问的内容**
静态方法中不能使用 this 关键字，也不能直接访问所属类的实例变量和实例方法，可直接访问静态相关的东西。

也不能使用 super 关键字

**2 实例方法可访问的内容**
如果方法没有用 static 修饰，那么它就是实例方法。 实例方法中可以直接访问所属类的静态变量，静态方法，实例变量和实例方法。

**3 静态方法必须被实现**
静态方法用来表示某个类所特有的功能，其实现不依赖于类的具体实例，也不依赖其子类。

所以一个静态方法不能被定义为抽象方法。

static 和 abstract 永远不能在一起使用，

**4 作为程序入口的 main() 方法是静态方法**

把 main() 方法定义为静态方法，可以使 jvm 只要加载了 main() 方法所属的类，就能执行 main() 方法，而无需先创建这个类的实例。

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g6q3r737ntj30u50u07ly.jpg)

**5 方法的字节码都位于方法区**

不管实例方法，还是静态方法，他们的字节码都位于**方法区内**
![](https://tva1.sinaimg.cn/large/006y8mN6ly1g6q3tewie4j31040gen2o.jpg)

### 4.3 static 代码块

jvm 在加载类时，会执行这些静态代码块，有多个静态代码块时，jvm 会按其出现的顺序一次执行他们。每个静态代码块只会被执行一次。

类的构造方法用于初始化类的实例，类的静态代快用于初始化类，给类的静态变量赋值初始化


## 5 小结

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g6q4629kj1j30u00x04ll.jpg)