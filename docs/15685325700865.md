# 内存模型概览

## 主内存与工作内存
![](https://github.com/CyC2018/CS-Notes/blob/master/notes/pics/15851555-5abc-497d-ad34-efed10f43a6b.png)

所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或则寄存器中，保存了该**线程使用的变量的主内存副本拷贝**

线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。

## 内存间交互操作
Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。

![](https://github.com/CyC2018/CS-Notes/blob/master/notes/pics/8b7ebbad-9604-4375-84e3-f412099d170c.png)


read：把一个变量的值从主内存传输到工作内存中
load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中
use：把工作内存中一个变量的值传递给执行引擎
assign：把一个从执行引擎接收到的值赋给工作内存的变量
store：把工作内存的一个变量的值传送到主内存中
write：在 store 之后执行，把 store 得到的值放入主内存的变量中
lock：作用于主内存的变量
unlock

## 内存模型三大特性

**1.原子性**
Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。**但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，**即 load、store、read 和 write 操作可以不具备原子性。

**为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。**


除了使用原子类之外，也可以使用 `synchronized` 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 `monitorenter` 和 `monitorexit`。


**2.可见性**
一个线程修改了共享变量的值，其它线程能够**立即**得知这个修改。`Java` 内存模型是通过**在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。**

主要有三种实现可见性的方式：
- volatile，保证可见性，不能保证原子性
- synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。
- final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（**其它线程通过 this 引用访问到初始化了一半的对象**），那么其它线程就能看见 final 字段的值。

**3.有序性**
有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，**所有操作都是无序的，无序是因为发生了指令重排序**。在 Java 内存模型中，允许编译器和处理器对**指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。**

volatile 关键字**通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。**

也可以通过 synchronized 来保证有序性，它保证每个时刻**只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。**

##先行发生原则
上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，**让一个操作无需控制就能先于另一个操作完成。**


**1. 单一线程原则**
**2. 管程锁定规则**
一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。

**3. volatile 变量规则**
对一个 volatile 变量的**写操作**先行发生于后面对这个变量的**读操作**。

**4. 线程启动规则**
Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。

**5. 线程加入规则**

**6. 线程中断规则**
对线程 interrupt() 方法的**调用**先行发生于被中断线程的代码检测到中断事件的发生，可以通过 `interrupted`() 方法检测到是否有中断发生。