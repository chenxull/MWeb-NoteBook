# 泛型编程

早期C++的许多工作是对C的强化和净化，并把完全兼容C作为强制要求。C++很大程度上就是用来解决C语言中的各种问题和各种不方便的，比如：

- 用引用来解决指针的问题
- 用namespace来解决名字空间冲突的问题
- 通过try-catch来解决名字空间返回值编程的问题
- 用class来解决对象的创建，复制销毁的问题，从而可以达到在结构体嵌套时可以深度复制的内存安全问题
- 通过重载操作符来达到操作上的泛型。
- 通过模板template和虚函数的多态以及运行时识别来达到更高层次的泛型和多态
- 用 RAII、智能指针的方式，解决了 C 语言中因为需要释放资源而出现的那些非常 ugly 也很容易出错的代码的问题。
- 用 STL 解决了 C 语言中算法和数据结构的 N 多种坑。

## C++ 泛型编程

理想情况下，算法应该是数据结构以及类型无关的，各种特殊的数据类型理应做好自己分内的工作，算法值关心一个标准的实现。**而对于泛型的抽象，如果我们的数据结构符合通用的算法，那么对数据类型的最小需求又是什么呢？**

C++解决程序泛型的方法有三点。

**第一，它通过类的方式来解决**
- 类里面会有构造函数，析构函数表示这个类的分配和释放
- 还有它的拷贝构造函数，表示了对内存的复制
- 还有重载操作符，用来定制化比较大于，等于，不等于

通过这种方式，让一个用户自定义的数据类型和内建的那些数据类型就很一致了。

**第二，通过模板达到类型和算法的妥协**（有点不太理解）
- 模板有点像DSL，模板的特化会根据使用者的类型在编译时期生成那个模板的代码
- 模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换时的问题

模板很好的取代了C时代宏定义带来的问题

**第三，通过虚函数和运行时类型识别**
- 虚函数带来的多态在语义上可以支持同一类的类型泛型
- 运行时类型识别技术可以做到在泛型时对具体类型的特殊处理

可以写出基于抽象类型的泛型。

一个好的泛型编程需要解决如下几个泛型编程问题：

- 算法的泛型
- 类型的泛型
- 数据结构（数据容器）的泛型。