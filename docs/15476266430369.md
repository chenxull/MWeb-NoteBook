# 起源

## 从C语言开始

1. C语言是一个静态弱类型语言，在使用变量时需要声明变量类型，但是类型间可以有隐式转换
2. 不同的变量类型可以用结构体组合在一起，以此声明新的数据类型；
3. C语言可以用typedef关键字来定义类型的别名，一次来达到变量类型的抽象
4. C语言是一个有结构化程序设计，具有变量作用域以及递归功能的过程式语言
5. C语言传递参数一般是以值传递，也可以传递指针
6. 通过指针，C语言可以容易的对内存进行低级控制，然后这引入了非常大的编程复杂度与
7. 编译预处理让C语言的编译更具有弹性，比如跨平台

### 例子

```c
void swap(int* x, int* y)
{
	int temp = *x;
	*x = *y;
	*y = tmp;
}

```

要想交换传入二个参数的值，必须使用指针，但是这个函数最大的问题就是它只能给int值用，这个世界上还有很多类型包括double，float，这就是静态语言最糟糕的一个问题。

### 数据类型与现实世界的类比

数据类型就好像螺帽一样，有多种接口方式：平口的，十字的，六角的等。螺丝刀就相当于函数，或是用来操作这些螺丝的算法或代码。为了适应不同类型的螺帽我们需要为之匹配一堆不同的螺丝刀。

这就是类型为编程带来的问题，要解决这个问题，我们通过使用一种更为通用的方式，用另外的话说就是抽象和隔离，让复杂的世界变得更简单一些。


要做到抽象，对于C语言这样的类型来说，首当其冲的就是抽象类型，这就是所谓的--泛型编程。

C语言实现的泛型太过于复杂，数据类型的自适应问题会把原来简单的问题弄的很复杂。

## 小结

程序 = 算法+数据  ，C语言会有这几个问题：

1. 一个通用的算法，需要对所处理的数据的数据类型进行适配。但是在适配数据类型的过程中，C语言只能使用void*或者宏替换方式，这二种方式导致了类型过于宽松，并带来很多其他问题。
2. 适配数据类型，需要C语言在泛型中加入一个类型的size，这是应为我们识别不了被泛型后的数据类型，而C语言没有运行时的类型识别。所有，只能将这个工作抛给调用泛型算法的成员来做。
3. 算法其实是在操作数据结构，而数据是放在数据结构中的。所有，真正的泛型除了适配数据类型外，还要适配数据结构。这会导致泛型算法的复杂度极剧上升。比如容器内存的分配和释放，不同的数据体可能有非常不一样的内存分配和释放模型，再比如对象之间的复制，要把它存进来我需要有一个复制，这其中又涉及到是深拷贝，还是浅拷贝。
4. 在实现泛型算法时，可能会纠结哪些东西应该让调用者处理，哪些可以封装起来，如何平衡和选择很难决定。