# 专业名词

## 幂等

幂等性原本是数学上的概念，即使公式：`f(x)=f(f(x))` 能够成立的数学性质。用在编程领域，则意为对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。

幂等性是分布式系统设计中十分重要的概念，具有这一性质的接口在设计时总是秉持这样的一种理念：调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。

### 实现机制

1. MVCC：多版本并发控制，乐观锁的一种实现，在数据更新时需要去比较持有数据的版本号，版本号不一致的操作无法成功。例如博客点赞次数自动+1的接口：
2. 去重表：利用数据库表单的特性来实现幂等，常用的一个思路是在表上构建唯一性索引，保证某一类数据一旦执行完毕，后续同样的请求再也无法成功写入。
3. TOKEN机制：这种机制就比较重要了，适用范围较广，有多种不同的实现方式。其核心思想是为每一次操作生成一个唯一性的凭证，也就是token。一个token在操作的每一个阶段只有一次执行权，一旦执行成功则保存执行结果。对重复的请求，返回同一个结果。以电商平台为例子，电商平台上的订单id就是最适合的token。当用户下单时，会经历多个环节，比如生成订单，减库存，减优惠券等等。


## UUID
是 通用唯一识别码（Universally Unique Identifier）的缩写，是一种软件建构的标准，亦为开放软件基金会组织在分布式计算环境领域的一部分。其目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。

## Image Manifest




                    +-----------------------+
                    | Image Index(optional) |
                    +-----------------------+
                               |
                               | 1..*
                               ↓
                    +----------------------+
                    |    Image Manifest    |
                    +----------------------+
                               |
                     1..1      |     1..*
               +---------------+--------------+
               |                              |
               ↓                              ↓
       +--------------+             +-------------------+
       | Image Config |             | Filesystem Layers |
       +--------------+             +-------------------+
 
         


The image manifest file will contain all the information which is needed to
pull, install, validate and run an image. It will contain a list of layers by
a content addressable id, history, run time configuration, and signatures.
This manifest is generated by the daemon. Initially this generation will happen
when an image is published, and ultimately happen anytime an image is built or
committed. Each manifest is required to be signed by the client creating the
manifest on push or build with additional signatures which can be added post
build to verify the quality of the manifest or validity of the builder. The
history will contain fully backward compatible metadata to allow old style
layer and metadata to be recreated from the manifest.

image manifest文件将包含所需的所有信息pull、install、validate和run一个image。它将包含一个layer列表其id是内容可寻址的、历史、运行时间配置和签名。这个manifest是由守护进程生成的。将会发生在一个image发布时，并且最终在构建image或提交的任何时刻。创建的客户端需要对每个清单进行签名在push或build上使用可以添加post的附加签名来显示构建以验证构建程序清单的质量或有效性。历史记录将包含完全向后兼容的元数据，以允许使用旧样式要从清单中重新创建的层和元数据。


```
{
   "name": "dmcgowan/test-image",
   "tag": "latest",
   "architecture": "amd64",
   "blobSums": [
      {
         "blobSum": "tarsum+sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      },
      {
         "blobSum": "tarsum+sha256:cea0d2071b01b0a79aa4a05ea56ab6fdf3fafa03369d9f4eea8d46ea33c43e5f",
      },
      {
         "blobSum": "tarsum+sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      },
      {
         "blobSum": "tarsum+sha256:2a7812e636235448785062100bb9103096aa6655a8f6bb9ac9b13fe8290f66df"
      }
   ],
   "history": ["v1 compatible string encoded json for each layer"],
   "schemaVersion": 1,
   "signatures": [
      {
         "header": {
            "jwk": {
               "crv": "P-256",
               "kid": "LYRA:YAG2:QQKS:376F:QQXY:3UNK:SXH7:K6ES:Y5AU:XUN5:ZLVY:KBYL",
               "kty": "EC",
               "x": "Cu_UyxwLgHzE9rvlYSmvVdqYCXY42E9eNhBb0xNv0SQ",
               "y": "zUsjWJkeKQ5tv7S-hl1Tg71cd-CqnrtiiLxSi6N_yc8"
            },
            "alg": "ES256"
         },
         "signature": "m3bgdBXZYRQ4ssAbrgj8Kjl7GNgrKQvmCSY-00yzQosKi-8UBrIRrn3Iu5alj82B6u_jNrkGCjEx3TxrfT1rig",
         "protected": "eyJmb3JtYXRMZW5ndGgiOjYwNjMsImZvcm1hdFRhaWwiOiJDbjAiLCJ0aW1lIjoiMjAxNC0wOS0xMVQxNzoxNDozMFoifQ"
      }
   ]
}
```

###The new image format drastically simplifies the concepts:

- an image is a json file, with a mandatory, namespaced name, a list of tarsums (eg: content-addressable layers ids), some opaque metadata, a signature
- a layer is a binary blob, mapping to a tarsum

### Content Addressable Layers

Each layer of an image will be referenced by a checksum created from its
contents. This checksum will be used on push and pull to verify contents have
not been tampered and disallow the layer referred to in the manifest to be
changed after signed.

## Blobs

 > [原文链接](https://ithelp.ithome.com.tw/articles/10077453)
 
BLOB Storage顾名思义，是专门用来储存二进位档案使用的储存服务，基本上档案的格式没有任何的限制，只要是可以转换成二进位资料（binary data）的档案都可以储存，也就是我们常说的非结构化（unstructured）资料，举凡一般的文字档案到大型的影音档案都可以使用。
BLOB Storage的概念和档案系统非常类似，每个储存帐户都有独立的URL命名空间，而命名空间下则是容器（container），资料则存放在容器内，容器的概念就像是资料夹一样，所以一个储存在BLOB中的档案的URL会是：
`http://[storagename ].blob.core.windows.net/[container name]/[blob name]`

在BLOB Storage中支援两种不同类型的资料，：
- 一种是划分为资料块（data block）的BLOB格式，档案由固定大小的资料块组成，用户端在操作此类型的BLOB时，可将资料划分成数个资料块后分批上传，最后再使用API​​将这些资料块组织成一个完整的档案，Storage在处理资料块时会使用两阶段认可程序（Two-phrase Commit），每个资料块在上传时都要经过服务认可才算成功，也就是说如果有资料块传输失败时，服务会要求用户端重传，直到全部传输完成后，再将所有的资料块认可成一个完整的档案。一个使用资料块保存的BLOB档案最多可拥有50,​​000个区块，而一个区块最大的长度为4MB，所以等于最大可以存放200GB的资料量。
- 另一个BLOB格式则是分页型（page）的BLOB，这个格式很类似于电脑中的记忆体，它是由连续位址组合而成的，用户端可以自由的决定要写入哪一段位址，服务也不会特别去检查是否完成就会直接认可，在速度上分页型的BLOB会比资料块型的BLOB要来的快，可用大小也比资料块的大，最高可用到1TB的资料量，适合需要连续写入资料的需求，而Windows Azure Drive也是使用这个类型的BLOB来实作的。

Blob 存储用于：
- 直接向浏览器提供图像或文档。
- 存储文件以供分布式访问。
- 对视频和音频进行流式处理。
- 向日志文件进行写入。
- 存储用于备份和还原、灾难恢复及存档的数据。
- 存储数据以供本地或 Azure 托管服务执行分析。

## 内容可寻址存储  content addressability

内容可寻址存储（也称为关联存储或缩写CAS）是一种存储信息的方式，因此可以根据其内容而不是其位置来检索信息。它已被用于高速存储和检索的固定内容，如存储，符合政府规定的文件。内容可寻址存储就像内容可寻址存储器。

CAS存储最有效地处理不经常更改的数据。对于必须遵守文档保留法的大型组织，例如Sarbanes-Oxley，尤为重要。在这些公司中，大量文件将被存储多达十年，没有变化和不经常访问。CAS旨在快速搜索给定的文档内容，并保证检索到的文档与最初存储的文档相同。（如果文档不同，它们的内容地址会有所不同。）此外，由于数据通过其包含的内容存储到CAS系统中，因此从不存在存储中存在多个相同文档的副本的情况。根据定义，两个相同的文档具有相同的内容地址，因此指向相同的存储位置。

## ORM
ORM全称是对象关系映射（object relational mapping），主要作用是在编程中，把面向对象的概念和数据库中的表的概念对应起来。具体来说，就是我定义一个对象，就对应着数据库中的一张表，这个对象的实例，就对应着表中的一条记录。

### 代码实例

拿Django的model举例：
```
from django.db import models

class User1(models.Model):
    name = models.CharField(max_length=255)
```
对应的数据库中可能就是一个表:user,里面有一个字段（我们假设不定义的自动不存在，包括主键），那就是name 类型是varchar(255)。

那么，如果我们有一个User的实例，比如:

```
user = User1()
user.name = 'the5fire'
user.save()   # 存入数据库
```
那么对应着数据库中就有一条记录，name为the5fire。此时的user实例，对应的正是这个表的这一条记录。

用ORM的好处就是你不用操作表，可以在程序中用面向对象的思路，直接操作对象即可。比如上面那个代码，我要插入一条语句，直接user.save()即可。ORM会帮我们产生一条SQL语句。

```
INSERT INTO user1(name) VALUES("the5fire");
```