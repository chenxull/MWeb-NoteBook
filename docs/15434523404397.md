# 课题组第二次汇报

2018年11月30日下午，汇报的大致内容为安全镜像仓库的具体实现以及自己构想的漏洞防范体系。目前的一些想汇报的东西有如下几个方面：

- 安全镜像仓库的整体架构，实现的大致细节框架
- 漏洞安全层级：
    - Package Vulnerability
    - Operation Vulnerability
    - Isolation Vulnerability

我们可以根据需要，开发出自己需要的组件，集成到整个安全仓库的架构中去。

## 一.安全镜像仓库系统整体架构

安全镜像仓库核心部分由6个组件完成。
![](http://www.think-foundry.com/wp-content/uploads/2016/09/article1_image2.png)

- Proxy: registry,UI,token 都在proxy之后，proxy的作用就是将来自浏览器，docker客户端的请求转发给各种后端服务。
- Registry: 负责存储docker镜像和处理Docker pull/push请求。安全镜像仓库需要对镜像实施访问控制，所以当客户端请求镜像时，Registry会将这个client request定向到token服务，以获取每个Pull/push请求的有效命令
- 核心服务
    - UI ：一个图像用户界面，帮助用户来管理Reistry上的镜像
    - Webhook：是Registry中配置的一种机制，可以将Regisry中的镜像状态更改填充到Harbor的webhook端点。
    - token服务:负责根据用户的项目角色为每个docker PULL/PUSH命令发送令牌，如果docker client发送的请求中没有token，Regisry会将请求重定向到令牌服务。
- Database ：存储项目，用户，角色，复制策略和镜像的元数据
- Job Services ：镜像复制，本地镜像可以复制同步到其他Harbor中
- Log conllector ：负责收集其他组件的日志信息。

上面的每一个组件都被包装为Docker容器，通过docker-compose部署。

### Docker Clinet登陆流程
假设将镜像仓库部署在地址为192.168.1.100的主机上，用户可以通过docker命令去访问这个镜像仓库。

当用户输入了要求的登录信息之后，docker client会向192.1681.1.100发送一个HTTP GET request。安全镜像仓库的各个容器组件将会依次处理这个请求。
![](http://www.think-foundry.com/wp-content/uploads/2016/09/article1_image3.png)

- a.这个请求被监听80端口的容器所接受，容器中的Nginx将这个请求转发给后端的Registry容器
- b.Registry容器已经配置了基于token 服务的身份验证，因此会返回错误代码401，通知Docker Client从指定的URL获取有效的token。 
- c.当Docker客户端收到401错误代码时，它会向令牌服务URL发送请求，在请求头中嵌入用户名和密码
- d.在通过端口80将该请求发送到代理容器之后，Nginx根据预先配置的规则将请求转发到UI容器，UI容器内的token服务接受请求，解码请求并获得用户名和密码。
- e.获得用户名和密码之后，token服务检查数据库并通过MySql数据库中的数据对对用户进行身份验证。身份验证成功之后，token服务将返回成功的HTTP代码。HTTP相应中包含了由私钥生成的token。

上面就是实现的一个docker登陆的过程。

### Docker Push流程
这个流程图省略了转发代理步骤，直接说明了通信的逻辑
![](http://www.think-foundry.com/wp-content/uploads/2016/09/article1_image4.png)

用户成功登陆之后，通过Docker Push命令将 Image上传到Registry。
```docker push 192.168.1.10/HPC/library/HelloWorld```

- a.docker client通过向Registry发送类似于login的请求，然后获取token服务的URL
- b.获得token之后，Docker client在push 镜像到Registry中增加了token信息
- c.在接受到Nginx转发的请求之后，token服务查询数据库以查找用户的角色和推送镜像的权限。如果用户的权限合适，它会对推送的操作信息进行编码，并使用私钥对其进行前面，并为Docker Clinet生成令牌。
- d.Docker client 获取令牌之后，它向Registry发送push请求，这个请求中包含了token。一旦Registry收到了这个请求，它会使用公钥解码令牌并验证其内。如果验证通过则镜像开始传输。




## 漏洞的层级

这里重新说明一下漏洞的维度，在这个安全体系中我将漏洞分为了3个不同的维度，每个维度的漏洞问题都针对安全问题的不同方面。从静态和动态的角度全方面解决安全问题。下图是整个体系的架构:

![](https://ws3.sinaimg.cn/large/006tNbRwly1fxp2p2vc2qj31aj0u0af9.jpg)

### 1.Package Vulnerability
我一直所谈的漏洞仅仅局限在了镜像所包含的package所带有的漏洞，这种漏洞是一种较深层次的漏洞，虽然看起来很危险，攻击者想利用这种漏洞来攻击容器还是有很大的困难的（个人猜测，需要验证 ），技术难度比较高。针对于这一层级的漏洞，我们可以使用使用上次开会提出的漏洞扫描方法，来解决这个问题。简而言之，很多漏洞虽然看起来很危险，但是在我们具体的环境中可能根本不会受到这种package漏洞的影响，没有必要去话大量的精力来解决这种安全漏洞。

#### 漏洞扫描策略
管理员可以根据漏洞的危害程度设置不同的防范级别，当开发者上传来的镜像经过扫描后发现漏洞危害程度超过预设值，这种镜像就会被禁止上传，不允许在生产环境中使用。

漏洞扫描会扫描镜像的所有文件，并展示在这个镜像中有多少包含有什么危害级别的漏洞。

漏洞扫描可以设置为镜像上传时来进行扫描，也可以根据每天的定时任务来进行扫描，利用波谷时的系统资源。

#### 应对措施
针对这个层级的漏洞我们需要做的是有一下几点；

1. 对于容器所存在的package漏洞做到心中有数，有详细的数据来反馈给我们
2. 对于这些被检测出来的漏洞，我们可以花时间去研究这些漏洞的机理是什么，是否会对我们的生产环境产生任何实际的影响。然后对这些漏洞做一个内部的危险评级，将这些数据整合到安全镜像仓库中去，来不断更新安全仓库的安全性能。
3. 如果确定某种package漏洞会对系统产生重大影响，立即停止含有这有package容器的运行，也禁止含有这种package镜像的上传，下载。对其进行隔离，将危害降到最小。



### 2.Operation Vulnerability
但是，如果如果我们扩大漏洞定义的范围，人为的操作配置错误也是漏洞的一种，而且这种漏洞的危险程度更加严重，因为这种配置的错误很容易被攻击者所利用来破坏甚至控制容器。

容器的主要应用在于微服务，微服务将传统的单体巨石服务拆分为众多服务，其端口数量的暴涨必然会导致攻击面的增多，每个服务的配置和访问都要处在适当的监管和保护之下，这些都需要更为细致的人为配置操作，大大增加了安全隐患。这些为服务之间可能共享数据，之间的联系以点对点的形式呈现，如果其中的一个服务因为安全漏洞被攻破，那么与其联接的服务也会受到牵连，从而整个系统都可能落入攻击者手中。

#### 操作的定义

- 如何定义容器之间的相互依赖关系（根据具体的应用服务来设计，但是如果设计的恰当，是否会给用户数据带来危险？）
- 容器数据的持久化存储解决方案，文件系统该如何的挂载
- 每个容器该赋予什么样的权限，给予什么样的capacity，AppArmor/SELinux服务该如何的去配置
- 给每个容器分配多少的内存,CPU和磁盘资源
- 对外提供服务的容器，端口该如何暴露
- 容器之间通信网络设计的是否合理？

等等这些都是在实际生产环境中会遇到的操作问题，还有更多的一些细节操作需要在生产过程中不断总结经验，来完善这一过程。如果配置的不当，会使的整个系统留下很大的安全隐患。

#### 应对措施

为了增强些配置操作的合理性，可以参考美国Center for Internet Security这个机构发布的Docker Benchmark来定制HPC环境中的Benchmark，通过这种方式来减少可能的漏洞攻击面。


### 3.Isolation Vulnerability

上述二个维度的漏洞问题涉及的都是静态的安全问题，针对的分别是静态镜像本身的漏洞以及在启动服务前相关配置可能存在的漏洞。但是在容器运行的过程中，可能会出现一些重大运行事故，上述这些漏洞解决方案就会束手无策，任由危险的扩散。

在实际的生产过程中，成千上万的容器部署在不同的主机上，不同的主机可能运行相同服务的容器，万一这些容器出现了问题，影响面就会十分的广泛，如果不及时加以控制隔离，会造成重大的生产事故。所以在这一方向上还有很多的工作需要去做。

目前大规模的容器编排部署都是使用kubernetes这一编排工具，下面就假设在HPC环境中也使用这一底层的容器编排工具。

在注意到上述问题之后，我们现在需要做的就是从动态这个层面进行安全隔离工作。对于运行在不同层级的服务做出相应的隔离，来确保万一发生安全事故一切都是可控可隔离的。隔离可以分为一下的层级


![](https://storage.googleapis.com/gweb-cloudblog-publish/original_images/Isolation-provided-by-layer-of-Kubernetessyjn.PNG)

#### 应对措施

虽然在整个系统上有太多的地方需要隔离，我们可以根据HPC环境做相应的加减法。对于这些隔离并不是越多越好，设置太多的隔离反而会限制系统的性能，增加整个系统的复杂度不便于后期的维护。

由于整个系统有很多的层级，不同层级的隔离程度也是不同，在后期的计划中，打算根据HPC环境中安全需求级别来制定不同层级的隔离程度，做到隔离效果和维护复杂度的一个平衡。

## 总结

目前我的工作主要集中在Package Vulnerability和Operation Vulnerability这二个层面，Isolation Vulnerability需要以后深入的研究，是一个长期的工作。

如果能够在实际的生产环境中能够完整的落实这一安全架构，将会大大增加系统的安全程度。


