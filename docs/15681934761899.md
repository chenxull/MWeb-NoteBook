# HashMap

## 1.7 版本

内部包含了一个 Entry 类型的数组 table。


Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用**拉链法**来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。

```
 Entry(int h, K k, V v, Entry<K,V> n) {
        value = v;
        next = n;
        key = k;
        hash = h;
    }
```
![](https://github.com/CyC2018/CS-Notes/blob/master/notes/pics/9420a703-1f9d-42ce-808e-bcb82b56483d.png)

**1. 拉链法工作原理**

应该注意到链表的插入是以头插法方式进行的，例如上面的 <K3,V3> 不是插在 <K2,V2> 后面，而是插入在链表头部。

查找需要分成两步进行：

- 计算键值对所在的桶；
- 在链表上顺序查找，时间复杂度显然和链表的长度成正比。


![](https://github.com/CyC2018/CS-Notes/blob/master/notes/pics/e0870f80-b79e-4542-ae39-7420d4b0d8fe.png)

**2. put 操作**

`HashMap` 允许插入键为 `null` 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过**强制指定**一个桶下标来存放。HashMap 使用第 **0** 个桶存放键为 null 的键值对。

使用**链表的头插法**，也就是新的键值对插在链表的头部，而不是链表的尾部。


**3. 确定桶下标**
- 计算 hash 值
- 取模， 将 key 的 hash 对桶的个数取模

**4 扩容-基本原理**

设 HashMap 的 table 长度为 M，**需要存储的键值对数量为 N**，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。

为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 **M** 尽可能大，**也就是说 table 要尽可能大**。HashMap 采用**动态扩容**来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g6vpolue6tj316g0baq5k.jpg)

当需要扩容时，令 capacity 为原来的两倍。
扩容使用 **resize()** 实现，需要注意的是，扩容操作同样需要把 **oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。**

**5 扩容-重新计算桶下标**
在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。

假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：

```
capacity     : 00010000
new capacity : 00100000
```

对于一个 Key，
- 它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；
- 如果为 1，那么得到的结果为原来的结果 +16。

**6. 计算数组容量**
HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。


**7 与 HashTable 的比较**
- HashTable 使用 synchronized 来进行同步。
- HashMap 可以插入键为 null 的 Entr
- HashMap 的迭代器是 fail-fast 迭代器。
- HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。


## jdk 1.8 
JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当**链表长度大于阈值（默认为 8）时**，将链表转化为红黑树，以减少搜索时间。


所谓**扰动函数**指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。
**hash 方法的区别**
相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。

### 构造方法
四个构造方法：
-  默认构造函数。
-  包含另一个“Map”的构造函数
-  指定“容量大小”的构造函数
-  指定“容量大小”和“加载因子”的构造函数


### put 方法
![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/put%E6%96%B9%E6%B3%95.png)

只提供了 put 用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。

- 如果定位到的数组位置没有元素 就直接插入。
- 如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就**判断p**是否是一个树节点，如果是就调用`e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value)` 将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。