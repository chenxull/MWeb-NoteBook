# CPU上下文切换

导致系统的负载升高的罪魁祸首就是CPU的上下文切换，因为linux拾亿贰多任务操作系统，它支持远大于cpu数量的任务同时运行。当然，这些任务实际上并不是真的在同时运行，而是因为系统在很短的时间内，将 CPU 轮流分配给它们，造成多任务同时运行的错觉。

每个任务运行前，cpu需要知道任务从哪里加载 ，从哪里开始运行，也就是说，系统事先帮它设置好**CPU寄存器和程序计数器**。

**CPU 寄存器**，是 CPU 内置的容量小、但速度极快的内存。而**程序计数器**，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 **CPU 上下文**。

![](https://static001.geekbang.org/resource/image/98/5f/98ac9df2593a193d6a7f1767cd68eb5f.png)

当有多个任务进行切换时，cpu就需要不停的对这些数据进行存储切换。这些保存的上下文会存储到系统内核中，并在任务重新调度执行时再次加载进来。这样就可以保证任务原来的状态不会受到影响，让任务看起来是连续运行的。
## CPU上下文切换的三种场景
根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，也就是进程上下文切换、线程上下文切换以及中断上下文切换。
### 进程上下文切换
Liunx按照特权等级，把进程空间分为内核空间和用户空间，分别对应着下面的Ring0和Ring3.
- 内核空间（Ring 0）具有最高权限，可以直接访问所有资源；
- 用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。
![](https://static001.geekbang.org/resource/image/4d/a7/4d3f622f272c49132ecb9760310ce1a7.png)

从用户态到内核态的转变：
1. 首先需要系统调用的完成，系统调用的过程发生了CPU上下文切换，CPU寄存器里原来用户态的指令位置需要先保存起来，
2. 接着为了执行内核态代码，CPU寄存器需要更新为内核态指令的新位置。
3. 最后才是跳转到内核态运行内核任务。

系统调用结束后，cpu寄存器需要恢复原来保存的用户态，然后在切换到用户空间。**所以一次系统调用的过程，其实是发生了二次cpu上下文切换**

需要注意，系统调用和进程上下文切换是不一样的：
- 进程上下文切换，是指从一个进程切换到另一个进程运行
- 系统调用的过程一直是同一个进程在运行，**系统调用通常称为特权模式切换，而不是上下文切换**

#### 进程上下文切换和系统调用的区别

首先，进程是由**内核**来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。

因此，进程的上下文切换就比系统调用时多了一步：**在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来**；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。
![](https://static001.geekbang.org/resource/image/39/6b/395666667d77e718da63261be478a96b.png)

#### 进程上下文切换的时机
只有在进程调度的时候，才需要进行切换上下文。Liunx为每个CPU都维护了一个就绪队列，将活跃进程按照优先级和等待cpu时间排序，然后选在最需要cpu的进程。

切换的时机：
1. 其一，为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。
2. 其二，进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。
3. 其三，当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。
4. 其四，当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。
5. 最后一个，发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序

### 线程上下文切换

线程和进程最大的区别在于，**线程是调度的基本单位，进程则是资源拥有的基本单位**，其实内核中的任务调度，实际上的调度对象是线程；进程只是给线程提供了虚拟内存，全局变量等资源。

它们之间的关系可以如此理解：
- 当进程只有一个线程时，可以认为进程就等于线程。
- 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。
- 另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。

### 中断上下文切换

为了快速响应硬件时间，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。

中断上下文切换不涉及到用户态。

## 工具
- `vmstat 1 1`：分析内存使用情况、cpu上下文切换和中断的次数。cs每秒上下文切换的次数，in每秒中断的次数，r运行或等待cpu的进程数，b中断睡眠状态的进程数。
- `pidstat -w 5`：查看每个进程详细情况。cswch（每秒自愿）上下文切换次数，如系统资源不足导致，nvcswch每秒非自愿上下文切换次数，如cpu时间片用完或高优先级线程
案例分析：
sysbench：多线程的基准测试工具，模拟context switch
终端1：sysbench --threads=10 --max-time=300 threads run
终端2：vmstat 1：sys列占用84%说明主要被内核占用，ur占用16%；r就绪队列8；in中断处理1w，cs切换139w==>等待进程过多，频繁上下文切换，内核cpu占用率升高
终端3：pidstat -w -u 1：sysbench的cpu占用100%（-wt发现子线程切换过多），其他进程导致上下文切换
watch -d cat /proc/interupts ：查看另一个指标中断次数，在/proc/interupts中读取，发现重调度中断res变化速度最快
总结：cswch过多说明资源IO问题，nvcswch过多说明调度争抢cpu过多，中断次数变多说明cpu被中断程序调用

### 小结

- CPU 上下文切换，是保证 Linux 系统正常工作的核心功能之一，一般情况下不需要我们特别关注。
- 但过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。