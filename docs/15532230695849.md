# LeetCode Go 语言刷题
### [888\. Fair Candy SwapCopy for Markdown](https://leetcode.com/problems/fair-candy-swap/)

Difficulty: **Easy**


Alice and Bob have candy bars of different sizes: `A[i]` is the size of the `i`-th bar of candy that Alice has, and `B[j]` is the size of the `j`-th bar of candy that Bob has.

Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy.  (_The total amount of candy a person has is the sum of the sizes of candy bars they have._)

Return an integer array `ans` where `ans[0]` is the size of the candy bar that Alice must exchange, and `ans[1]` is the size of the candy bar that Bob must exchange.

If there are multiple answers, you may return any one of them.  It is guaranteed an answer exists.


**Example 1:**

```
Input: A = [1,1], B = [2,2]
Output: [1,2]
```


**Example 2:**

```
Input: A = [1,2], B = [2,3]
Output: [1,2]
```


**Example 3:**

```
Input: A = [2], B = [1,3]
Output: [2,3]
```


**Example 4:**

```
Input: A = [1,2,5], B = [2,4]
Output: [5,4]
```

**<span style="display: inline;">Note:</span>**

*   <span style="display: inline;">`1 <= A.length <= 10000`</span>
*   <span style="display: inline;">`1 <= B.length <= 10000`</span>
*   `<span style="display: inline;">1 <= A[i] <= 100000</span>`
*   `<span style="display: inline;">1 <= B[i] <= 100000</span>`
*   It is guaranteed that Alice and Bob have different total amounts of candy.
*   It is guaranteed there exists an answer.


#### 1.Solution

这道题的核心点在于，认识到A和B之间差值的二分之一，是A或B 需要增加或减小的数字。如果想要交换成功，只要满足A中的元素加上这个差值后得到的值能在B中找到对应的元素，则可以交换：
valA+diff == valB 

Language: **Go**

```go

func sumArray(A []int) int {
	sum := 0
	for _, val := range A {
		sum += val
	}
	return sum
}

func fairCandySwap(A []int, B []int) []int {
    sumA := sumArray(A)
	sumB := sumArray(B)
	sum := sumA + sumB
	//fmt.Println(sumA, sumB)
	mapB := make(map[int]int)
	var ans []int
	for k, v := range B {
		mapB[v] = k
	}
	//fmt.Println(mapB)

	for _, val := range A {
		//fmt.Println("val:", val)
		need := sum/2 - (sumA - val)
		//fmt.Println("need:", need)
		if _, ok := mapB[need]; ok {
			ans = append(ans, val, need)
			break
		}
	}
	return ans
}
```

#### 2.Solution


```go

func fairCandySwap(A []int, B []int) []int {
	diff := 0
	mp := make(map[int]bool, len(A))
	for _, val := range A {
		diff += val
		mp[val] = true
	}

	for _, val := range B {
		diff -= val
	}

	diff >>= 1
	for _, val := range B {
		if mp[val+diff] {
			return []int{val + diff, val}
		}
	}
	panic("error")
}
```


### [283\. Move ZeroesCopy for Markdown](https://leetcode.com/problems/move-zeroes/)

Difficulty: **Easy**


Given an array `nums`, write a function to move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.

**Example:**

```
Input: [0,1,0,3,12]
Output: [1,3,12,0,0]```

**Note**:

1.  You must do this **in-place** without making a copy of the array.
2.  Minimize the total number of operations.


#### Solution

1. 找出非0元素出现的最后坐标lastNonZeroFoundAt
2. 将非0元素坐标之后的位置全部设为0

Language: **Go**

```go
func moveZeroes(nums []int)  {
    if nums == nil {
		return nil
	}
	lastNonZeroFoundAt := 0
	for i := 0; i < len(nums); i++ {
		if nums[i] != 0 {
			nums[lastNonZeroFoundAt] = nums[i]
			lastNonZeroFoundAt++
		}
	}

	for i := lastNonZeroFoundAt; i < len(nums); i++ {
		nums[i] = 0
	}
	return nums
}
```

### [448\. Find All Numbers Disappeared in an Array](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/)

Difficulty: **Easy**


Given an array of integers where 1 ≤ a[i] ≤ _n_ (_n_ = size of array), some elements appear twice and others appear once.

Find all the elements of [1, _n_] inclusive that do not appear in this array.

Could you do it without extra space and in O(_n_) runtime? You may assume the returned list does not count as extra space.

**Example:**

```
Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]
```


#### Solution

因为本题要求不使用额外的空间，对于数组题来说，这种要求必须要想到使用 hash 或则使用数组元素作为下标来进行求解。

遍历整个数组，将数组中元素对应下标位置的元素标记成负数，如果数组中元素没有重复，每个下标就会对应一个元素，这样一次遍历之后，所有元素都会被标记为负数。如果数组 array[i]为整数，则表示数组中没有 i+1这个数字。

Language: **Go**

```go
func findDisappearedNumbers(nums []int) []int {
    if nums == nil || len(nums) == 0 {
		return nil
	}

	for i := 0; i < len(nums); i++ {
		val := abs(nums[i]) - 1
		if nums[val] > 0 {
			nums[val] = -nums[val]
		}
	}
	var ans []int
	for i := 0; i < len(nums); i++ {
		if nums[i] > 0 {
			ans = append(ans, i+1)
		}
	}
	return ans
}

func abs(i int) int {
	if i < 0 {
		return -i
	}
	return i
}
```


### [169\. Majority Element](https://leetcode.com/problems/majority-element/)

Difficulty: **Easy**


Given an array of size _n_, find the majority element. The majority element is the element that appears **more than** `⌊ n/2 ⌋` times.

You may assume that the array is non-empty and the majority element always exist in the array.

**Example 1:**

```
Input: [3,2,3]
Output: 3```

**Example 2:**

```
Input: [2,2,1,1,1,2,2]
Output: 2
```


#### Solution

Language: **Go**

```go
func majorityElement(nums []int) int {
    count := 0
	var candidate int
	for _, val := range nums {
		if count == 0 {
			candidate = val
		}
		if val == candidate {
			count++
		} else {
			count--
		}
	}

	return candidate
}
```

### [1\. Two Sum](https://leetcode.com/problems/two-sum/)

Difficulty: **Easy**


Given an array of integers, return **indices** of the two numbers such that they add up to a specific target.

You may assume that each input would have **_exactly_** one solution, and you may not use the _same_ element twice.

**Example:**

```
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
```


#### Solution

在使用 map 数据结构存储数据时，出现一个问题。对于数组[3,3]，如果提前将这些数据存储到 map 中，map 只会有一条数据为` map[int]int:3,1`，`3，0`这个数据会被覆盖。所以需要赋值和对比同时进行，这样才能确保不会出现这种问题。

这个给定的数据是无序的，所以不能使用快速排序的思想，使用左右二个指针对数组遍历。

Language: **Go**

```go
func twoSum(nums []int, target int) []int {
    if nums == nil || len(nums) == 0 {
		return nums
	}
	mp := make(map[int]int)

	for i, num := range nums {
		fmt.Println(i, num)
		if _, ok := mp[target-num]; ok {
			return []int{mp[target-num], i}
		}
		mp[num] = i
	}
	return []int{}
}
```

### [167\. Two Sum II - Input array is sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)

Difficulty: **Easy**


Given an array of integers that is already **_sorted in ascending order_**, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.

**Note:**

*   Your returned answers (both index1 and index2) are not zero-based.
*   You may assume that each input would have _exactly_ one solution and you may not use the _same_ element twice.

**Example:**

```
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9\. Therefore index1 = 1, index2 = 2.```


#### Solution


这题的数据是有序的，可以使用快排的思想来遍历数据。
Language: **Go**

```go
func twoSum(numbers []int, target int) []int {
    if numbers == nil || len(numbers) == 0 {
		return numbers
	}
	i := 0
	j := len(numbers) - 1
	for i < j {
		val := numbers[i] + numbers[j]
		if val == target {
			return []int{i + 1, j + 1}
		} else if val > target {
			j--
		} else {
			i++
		}
	}
	return []int{}
}
```


### [697\. Degree of an Array](https://leetcode.com/problems/degree-of-an-array/)

Difficulty: **Easy**


Given a non-empty array of non-negative integers `nums`, the **degree** of this array is defined as the maximum frequency of any one of its elements.

Your task is to find the smallest possible length of a (contiguous) subarray of `nums`, that has the same degree as `nums`.

**Example 1:**  

```
Input: [1, 2, 2, 3, 1]
Output: 2
Explanation: 
The input array has a degree of 2 because both elements 1 and 2 appear twice.
Of the subarrays that have the same degree:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
The shortest length is 2\. So return 2.
```

**Example 2:**  

```
Input: [1,2,2,3,1,4,2]
Output: 6
```

**Note:**

*   `nums.length` will be between 1 and 50,000.*   `nums[i]` will be an integer between 0 and 49,999.

#### Solution

Language: **Go**

```go
func findShortestSubArray(nums []int) int {
    	var degree int
	mp := make(map[int][]int)
	for key, val := range nums {
		mp[val] = append(mp[val], key)
		if len(mp[val]) > degree {
			degree = len(mp[val])
		}
	}

	var ans int
	for _, slice := range mp {
		if len(slice) == degree {
			result := slice[len(slice)-1] - slice[0] + 1
			fmt.Println(result)
			if ans == 0 || result < ans {
				ans = result
			}
		}
	}
	return ans
}
```

### [217\. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)

Difficulty: **Easy**


Given an array of integers, find if the array contains any duplicates.

Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.

**Example 1:**

```
Input: [1,2,3,1]
Output: true```

**Example 2:**

```
Input: [1,2,3,4]
Output: false```

**Example 3:**

```
Input: [1,1,1,3,3,4,3,2,4,2]
Output: true```


#### Solution

Language: **Go**

```go
func containsDuplicate(nums []int) bool {
    mp := make(map[int][]int)
	for key, val := range nums {
		mp[val] = append(mp[val], key)
		if len(mp[val]) > 1 {
			return true
		}
	}
	return false
}
```


### [661\. Image SmootherCopy for MarkdownCopy for Markdown](https://leetcode.com/problems/image-smoother/)

Difficulty: **Easy**


Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can.

**Example 1:**  

```
Input:
[[1,1,1],
 [1,0,1],
 [1,1,1]]
Output:
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]
Explanation:
For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0
For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0
For the point (1,1): floor(8/9) = floor(0.88888889) = 0
```

**Note:**  

1.  The value in the given matrix is in the range of [0, 255].
2.  The length and width of the given matrix are in the range of [1, 150].


#### Solution


直接遍历求解即可，需要注意边界条。
Language: **Go**

```go
func imageSmoother(M [][]int) [][]int {
    if M == nil || len(M) == 0 {
		return M
	}
	row := len(M)
	col := len(M[0])
	ans := make([][]int, len(M))
	for i := 0; i < len(M); i++ {
		ans[i] = make([]int, len(M[0]))
	}

	for i := 0; i < row; i++ {
		for j := 0; j < col; j++ {
			count := 0
			for br := i - 1; br <= i+1; br++ {
				for bc := j - 1; bc <= j+1; bc++ {
					if br >= 0 && br < row && bc >= 0 && bc < col {
						ans[i][j] += M[br][bc]
						count++
					}
				}
			}
			ans[i][j] /= count
		}
	}
	return ans
}
```


### [268\. Missing Number](https://leetcode.com/problems/missing-number/)

Difficulty: **Easy**


Given an array containing _n_ distinct numbers taken from `0, 1, 2, ..., n`, find the one that is missing from the array.

**Example 1:**

```
Input: [3,0,1]
Output: 2
```

**Example 2:**

```
Input: [9,6,4,2,3,5,7,0,1]
Output: 8
```

**Note**:  
Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?


#### Solution

Language: **Go**

```go
func missingNumber(nums []int) int {
   if nums == nil || len(nums) == 0 {
		return -1
	}
	mp := make(map[int]bool)
	for _, val := range nums {
		mp[val] = true
	}
	for i := 0; i <= len(nums); i++ {
		if _, ok := mp[i]; !ok {
			return i
		}
	}
	return -1 
}
```


#### Solution

直接求出n 个数的和，然后减去一直数据的和，就可以得到缺少的数据是多少。
```go
func missingNumber(nums []int) int {
	if nums == nil || len(nums) == 0 {
		return -1
	}
	n := len(nums)
	var sum int
	for _, val := range nums {
		sum += val
	}
	return n*(n+1)/2 - sum
}
```

### [830\. Positions of Large Groups](https://leetcode.com/problems/positions-of-large-groups/)

Difficulty: **Easy**


In a string `S` of lowercase letters, these letters form consecutive groups of the same character.

For example, a string like `S = "abbxxxxzyy"` has the groups `"a"`, `"bb"`, `"xxxx"`, `"z"` and `"yy"`.

Call a group _large_ if it has 3 or more characters.  We would like the starting and ending positions of every large group.

The final answer should be in lexicographic order.

**Example 1:**

```
Input: "abbxxxxzzy"
Output: [[3,6]]
Explanation: "xxxx" is the single large group with starting  3 and ending positions 6.
```

**Example 2:**

```
Input: "abc"
Output: []
Explanation: We have "a","b" and "c" but no large group.
```

**Example 3:**

```
Input: "abcdddeeeeaabbbcd"
Output: [[3,5],[6,9],[12,14]]```

**Note: ** `1 <= S.length <= 1000`


#### Solution

直接对字符串进行操作，用二个指针i，j
- 开始时，指针 i，j 指向相同的元素
- 循环遍历，i 指向当前组的开始，递增j直到它到达组的尾部，当 j-i >= 3时将 i和 j 的结果放入到 [][]ans数组中。

Language: **Go**

```go
func largeGroupPositions(S string) [][]int {
    if len(S) == 0 {
		return [][]int{}
	}
	var ans [][]int
	i := 0
	for i < len(S) {
		start := i
		endChar := S[i]
		for i < len(S) && endChar == S[i] {
			i++
			//fmt.Println("debug")
		}
		//fmt.Println(start, i-1)
		if i-start >= 3 {
			//fmt.Println(start, i-1)
			ans = append(ans, []int{start, i - 1})
		}

	}
	return ans
}
```

### [121\. Best Time to Buy and Sell StockCopy for Markdown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

Difficulty: **Easy**


Say you have an array for which the _i_<sup>th</sup> element is the price of a given stock on day _i_.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

**Example 1:**

```
Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
```

**Example 2:**

```
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
```


#### Solution

核心思想：最大利润肯定需要确保的一点就是，要在股价最低点买入，在剩下的最高点卖出。因为最高的不可控，可以提前确定的是最低点。在二个 if 语句中，一个记录低点另一个记录利润最大值。
Language: **Go**

```go
func maxProfit(prices []int) int {
    if prices == nil || len(prices) == 0 {
		return 0
	}
	minprice := prices[0]
	var maxprofit int
	for i := 0; i < len(prices); i++ {
		if prices[i] < minprice {
			minprice = prices[i]
		} else if prices[i]-minprice > maxprofit {
			maxprofit = prices[i] - minprice
		}
	}
	return maxprofit
}
```



### [709\. To Lower Case](https://leetcode.com/problems/to-lower-case/)

Difficulty: **Easy**


Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.


**Example 1:**

```
Input: "Hello"
Output: "hello"
```


**Example 2:**

```
Input: "here"
Output: "here"
```


**Example 3:**

```
Input: "LOVELY"
Output: "lovely"
```


#### Solution

Language: **Go**

```go
func toLowerCase(str string) string {
    return strings.ToLower(str)
}
```


### [804\. Unique Morse Code Words](https://leetcode.com/problems/unique-morse-code-words/)

Difficulty: **Easy**


International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: `"a"` maps to `".-"`, `"b"` maps to `"-..."`, `"c"` maps to `"-.-."`, and so on.

For convenience, the full table for the 26 letters of the English alphabet is given below:

```
[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]

```

Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, "cba" can be written as "-.-..--...", (which is the concatenation "-.-." + "-..." + ".-"). We'll call such a concatenation, the transformation of a word.

Return the number of different transformations among all words we have.

```
Example:
Input: words = ["gin", "zen", "gig", "msg"]
Output: 2
Explanation: 
The transformation of each word is:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

There are 2 different transformations, "--...-." and "--...--.".

```

**Note:**

*   The length of `words` will be at most `100`.
*   Each `words[i]` will have length in range `[1, 12]`.
*   `words[i]` will only consist of lowercase letters.


#### Solution

判断单词的摩斯码是否相同，总共有几个不同的摩斯码。将这些单词对应的摩斯码用 map[string]bool 保存起来。最后通过判断 map 的长度即可得知有几个不同的摩斯码。

第一个 for 循环提起出单词数组中的单个单词，第二 for 循环将单个单词转换成rune数组，然后遍历获取单词中的每个字母。每个字符减'a'可以得到其在摩斯码表中的位置，以此来得到每个单词的摩斯码。


Language: **Go**

```go
func uniqueMorseRepresentations(words []string) int {
    	Mores := []string{".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."}
	translations := make(map[string]bool)

	for _, value := range words {
		translation := ""
		runes := []rune(value)
		for _, r := range runes {
			index := r - 'a' //在 mores code 数组中的下标
			//fmt.Println(string(r), index)
			translation += Mores[index]
		}
		translations[translation] = true
	}

	return len(translations)
}
```

### [929\. Unique Email AddressesCopy for Markdown](https://leetcode.com/problems/unique-email-addresses/)

Difficulty: **Easy**


Every email consists of a local name and a domain name, separated by the @ sign.

For example, in `alice@leetcode.com`, `alice` is the local name, and `leetcode.com` is the domain name.

Besides lowercase letters, these emails may contain `'.'`s or `'+'`s.

If you add periods (`'.'`) between some characters in the **local name** part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, `"alice.z@leetcode.com"` and `"alicez@leetcode.com"` forward to the same email address.  (Note that this rule does not apply for domain names.)

If you add a plus (`'+'`) in the **local name**, everything after the first plus sign will be **ignored**. This allows certain emails to be filtered, for example `m.y+name@email.com` will be forwarded to `my@email.com`.  (Again, this rule does not apply for domain names.)

It is possible to use both of these rules at the same time.

Given a list of `emails`, we send one email to each address in the list.  How many different addresses actually receive mails? 


**Example 1:**

```
Input: ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]
Output: 2
Explanation: "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails
```

**Note:**

*   `1 <= emails[i].length <= 100`
*   `1 <= emails.length <= 100`
*   Each `emails[i]` contains exactly one `'@'` character.


#### Solution

这道题目在判断有几个不同的 email 时，采用的思路和上题类似，都是设置map[string]bool，来存放不同的email。

剩下的几个函数就是用来分阶段处理'.','+','@'的

Language: **Go**

```go
func numUniqueEmails(emails []string) int {
    	translations := make(map[string]bool, 101)
	for _, email := range emails {
		translations[clean(email)] = true
		fmt.Println(clean(email))
	}
	return len(translations
}


//处理 ‘.’,'+','@'
func clean(email string) string {
	//根据@将 email 进行分割，后半部分不需要进行处理，主要是前半部分
	index := strings.IndexByte(email, '@')
	return deleteDot(trimPuls(email[:index])) + email[index:]
}

// 处理localName 中的‘.’
func deleteDot(localName string) string {
	return strings.Replace(localName, ".", "", -1)
}

// 处理 localName 中的 '+'
func trimPuls(localName string) string {
	index := strings.IndexByte(localName, '+')
	if index == -1 {
		return localName
	}
	// fmt.Println("debug:", localName[:index])
	return localName[:index]
}

func main() {
	Input := []string{"test.emailalex@leetcode.com", "test.e.mail+bob.cathy@leetcode.com", "testemail+david@lee.tcode.com"}
	fmt.Println(numUniqueEmails(Input))
}
```

### [657\. Robot Return to OriginCopy for Markdown](https://leetcode.com/problems/robot-return-to-origin/)

Difficulty: **Easy**


There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot **ends up at (0, 0)** after it completes its moves.

The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false.

**Note**: The way that the robot is "facing" is irrelevant. "R" will always make the robot move to the right once, "L" will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.

**Example 1:**

```
Input: "UD"
Output: true 
Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.
```

**Example 2:**

```
Input: "LL"
Output: false
Explanation: The robot moves left twice. It ends up two "moves" to the left of the origin. We return false because it is not at the origin at the end of its moves.
```


#### Solution

Language: **Go**

```go
func judgeCircle(moves string) bool {
    position := []int{0, 0}
	runes := []rune(moves)
	for _, step := range runes {
		if step == 'R' {
			position[1]++
		} else if step == 'L' {
			position[1]--
		} else if step == 'U' {
			position[0]++
		} else if step == 'D' {
			position[0]--
		} else {
			continue
		}
	}

	if position[0] == 0 && position[1] == 0 {
		return true
	}
	return false}
```

### [557\. Reverse Words in a String III](https://leetcode.com/problems/reverse-words-in-a-string-iii/)

Difficulty: **Easy**


Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.

**Example 1:**  

```
Input: "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"
```

**Note:** In the string, each word is separated by single space and there will not be any extra space in the string.


#### Solution
将 string 类型的数据转换成 []rune类型，可以很方便的对其中的每个元素进行操作，返回的时候只需要强制转换为 string 类型即可
Language: **Go**

```go
func reverseWords(s string) string {
    	sliceworld := strings.Split(s, " ")
	var result []string
	for _, world := range sliceworld {
		runes := []rune(world)
		ans := reverse(runes)
		result = append(result, ans)
	}
	return strings.Join(result, " ")
}


func reverse(world []rune) string {
	if len(world) < 2 {
		return string(world)
	}
	i := 0
	j := len(world) - 1
	for i < j {
		world[i], world[j] = world[j], world[i]
		i++
		j--
	}
	return string(world)
}
```

### [344\. Reverse String](https://leetcode.com/problems/reverse-string/)

Difficulty: **Easy**


Write a function that reverses a string. The input string is given as an array of characters `char[]`.

Do not allocate extra space for another array, you must do this by **modifying the input array ** with O(1) extra memory.

You may assume all the characters consist of .


**Example 1:**

```
Input: ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]
```


**Example 2:**

```
Input: ["H","a","n","n","a","h"]
Output: ["h","a","n","n","a","H"]
```


#### Solution

Language: **Go**

```go
func reverseString(s []byte)  {
    j := len(s) - 1
	for i := 0; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}
```


### [937\. Reorder Log Files](https://leetcode.com/problems/reorder-log-files/)

Difficulty: **Easy**


You have an array of `logs`.  Each log is a space delimited string of words.

For each log, the first word in each log is an alphanumeric _identifier_.  Then, either:

*   Each word after the identifier will consist only of lowercase letters, or;
*   Each word after the identifier will consist only of digits.

We will call these two varieties of logs _letter-logs_ and _digit-logs_.  It is guaranteed that each log has at least one word after its identifier.

Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order.

Return the final order of the logs.


**Example 1:**

```
Input: ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]
Output: ["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]
```

**Note:**

1.  `0 <= logs.length <= 100`
2.  `3 <= logs[i].length <= 100`
3.  `logs[i]` is guaranteed to have an identifier, and a word after the identifier.


#### Solution
还不会写，看了网上的解法，对于其中的一些语法特性还没能理解
Language: **Go**

```go
func reorderLogFiles(logs []string) []string {
    
}
```

### [824\. Goat Latin](https://leetcode.com/problems/goat-latin/)

Difficulty: **Easy**


A sentence `S` is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.

We would like to convert the sentence to "_Goat Latin"_ (a made-up language similar to Pig Latin.)

The rules of Goat Latin are as follows:

*   If a word begins with a vowel (a, e, i, o, or u), append `"ma"` to the end of the word.  
    For example, the word 'apple' becomes 'applema'.  

*   If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add `"ma"`.  
    For example, the word `"goat"` becomes `"oatgma"`.  

*   Add one letter `'a'` to the end of each word per its word index in the sentence, starting with 1.  
    For example, the first word gets `"a"` added to the end, the second word gets `"aa"` added to the end and so on.

Return the final sentence representing the conversion from `S` to Goat Latin. 

**Example 1:**

```
Input: "I speak Goat Latin"
Output: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"
```

**Example 2:**

```
Input: "The quick brown fox jumped over the lazy dog"
Output: "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"
```

Notes:

*   `S` contains only uppercase, lowercase and spaces. Exactly one space between each word.
*   `1 <= S.length <= 150`.


#### Solution

这题在理解题目意思后，将处理过程分为几个阶段即可。首先是对数组分片，然后构造出每次需要加到末尾的字符串，然后判断单词是否是元音开头，做相应的处理，最后返回生成的单词。

以后的代码都要自己写单元测试和基准测试。

Language: **Go**

```go
func toGoatLatin(S string) string {
    worlds := strings.Split(S, " ")
	for index := range worlds {
		worlds[index] = handleWorld(worlds[index], index)
	}
	return strings.Join(worlds, " ")
}
func handleWorld(world string, count int) string {
	profix := "ma" + strings.Repeat("a", count+1)
	if isBeginsWithVowel(world) {
		return world + profix
	}

	return world[1:] + world[0:1] + profix
}

func isBeginsWithVowel(world string) bool {

	switch world[0] {
	case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':
		return true
	default:
		return false
	}
}
```

### [521\. Longest Uncommon Subsequence I](https://leetcode.com/problems/longest-uncommon-subsequence-i/)

Difficulty: **Easy**


Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be **any** subsequence of the other strings.

A **subsequence** is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.

The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.

**Example 1:**  

```
Input: "aba", "cdc"
Output: 3
Explanation: The longest uncommon subsequence is "aba" (or "cdc"), because "aba" is a subsequence of "aba", but not a subsequence of any other strings in the group of two strings. 
```

**Note:**

1.  Both strings' lengths will not exceed 100.
2.  Only letters from a ~ z will appear in input strings.


#### Solution

如果对传入的二个字符串，每个字母的进行对比计算，这题就会变得十分复杂，不过通过分析之后，可以用一种十分简单的方式求解。

- a=b. If both the strings are identical, it is obvious that no subsequence will be uncommon. Hence, return -1.

- length(a)=length(b)length(a)=length(b) and a \ne ba =b. Example: abcabc and abdabd. In this case we can consider any string i.e. abcabc or abdabd as a required subsequence, as out of these two strings one string will never be a subsequence of other string. Hence, return length(a)length(a) or length(b)length(b).

- length(a) \ne length(b)length(a)=length(b). Example abcdabcd and abcabc. In this case we can consider bigger string as a required subsequence because bigger string can't be a subsequence of smaller string. Hence, return max(length(a),length(b))max(length(a),length(b)).



Language: **Go**

```go
func findLUSlength(a string, b string) int {
    if a == b {
		return -1
	}
	return max(len(a), len(b))
}

func max(i, j int) int {
	if i > j {
		return i
	}
	return j
}
```

### [521\. Longest Uncommon Subsequence I](https://leetcode.com/problems/longest-uncommon-subsequence-i/)

Difficulty: **Easy**


Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be **any** subsequence of the other strings.

A **subsequence** is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.

The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.

**Example 1:**  

```
Input: "aba", "cdc"
Output: 3
Explanation: The longest uncommon subsequence is "aba" (or "cdc"), because "aba" is a subsequence of "aba", but not a subsequence of any other strings in the group of two strings. 
```

**Note:**

1.  Both strings' lengths will not exceed 100.
2.  Only letters from a ~ z will appear in input strings.


#### Solution


这题比较常规，就是在普通的字符串逆序的基础上，加上了对字符的判断。
Language: **Go**

```go
func findLUSlength(a string, b string) int {
    world := []byte(S)
	left := 0
	right := len(world) - 1
	for left < right {
		for left < right && !isLetter(world[left]) {
			left++
		}
		for left < right && !isLetter(world[right]) {
			right--
		}
		world[left], world[right] = world[right], world[left]
		left++
		right--
	}
	return string(world)
}


func isLetter(s byte) bool {
	return s <= 'z' && s >= 'a' ||
		s <= 'Z' && s >= 'A'
}
```


### [788\. Rotated Digits](https://leetcode.com/problems/rotated-digits/)

Difficulty: **Easy**


X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X.  Each digit must be rotated - we cannot choose to leave it alone.

A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid.

Now given a positive number `N`, how many numbers X from `1` to `N` are good?

```
Example:
Input: 10
Output: 4
Explanation: 
There are four good numbers in the range [1, 10] : 2, 5, 6, 9.
Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.
```

**Note:**

*   N  will be in range `[1, 10000]`.


#### Solution

Language: **Go**

```go
func rotatedDigits(N int) int {
    result := 0

	for i := 2; i <= N; i++ {
		flag := isvalid(i)
		if flag {
			result++
		}
	}
	return result
}


func isvalid(c int) bool {
	var flag bool
	for c > 0 {

		switch c % 10 {
		case 2, 5, 6, 9:
			flag = true
		case 3, 4, 7:
			return false

		}
		c = c / 10

	}
	return flag

}
```

### [696\. Count Binary SubstringsCopy for MarkdownCopy for MarkdownCopy for MarkdownCopy for Markdown](https://leetcode.com/problems/count-binary-substrings/)

Difficulty: **Easy**


Give a string `s`, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.

Substrings that occur multiple times are counted the number of times they occur.

**Example 1:**  

```
Input: "00110011"
Output: 6
Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".
Notice that some of these substrings repeat and are counted the number of times they occur.
Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.
```

**Example 2:**  

```
Input: "10101"
Output: 4
Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.
```

**Note:**

*   `s.length` will be between 1 and 50,000.*   `s` will only consist of "0" or "1" characters.

#### Solution


从给定的数据中找到规律，寻找相邻的二个数据之间最小的值，然后将这些所有的最小值加起来。

首先定义一个groups 里面每个元素表示 在这个字符串中相同字符连续块的长度为多少。比如`if s = "110001111000000", then groups = [2, 3, 4, 6].`

同过对比 groups 中相邻二个元素的最小值，然后将这些最小值相加，即可求解。
Language: **Go**

```go
func countBinarySubstrings(s string) int {
    groups := make([]int, len(s))
	runes := []rune(s)
	index := 0
	groups[0] = 1
	//fmt.Println(groups[0])
	for i := 1; i < len(s); i++ {
		if runes[i-1] != runes[i] {
			index++
			groups[index] = 1
		} else {
			groups[index]++
		}
	}
	//fmt.Println(groups, index)
	var result int
	for i := 1; i <= index; i++ {
		result += min(int(groups[i-1]), int(groups[i]))
	}
	return result
}


func min(x, y int) int {
	if x > y {
		return y
	}
	return x

}
```

#### Solution2
解法二在一的基础上，没有使用 groups 数组，而是将每次计算出来的结果直接存储起来，最后在返回的时候还缺少最后一次对比，所有需要在调用 min 计算最后一次的数据。

```go
func countBinarySubstrings(s string) int {

	ans, pre, cur := 0, 0, 1
	runes := []rune(s)
	for i := 1; i < len(s); i++ {
		if runes[i-1] != runes[i] {
			ans += min(pre, cur)
			pre = cur
			cur = 1
		} else {
			cur++
		}
	}
	return ans + min(pre, cur)

}

func min(x, y int) int {
	if x > y {
		return y
	}
	return x

}
```

### [520\. Detect Capital](https://leetcode.com/problems/detect-capital/)

Difficulty: **Easy**


Given a word, you need to judge whether the usage of capitals in it is right or not.

We define the usage of capitals in a word to be right when one of the following cases holds:

1.  All letters in this word are capitals, like "USA".
2.  All letters in this word are not capitals, like "leetcode".
3.  Only the first letter in this word is capital if it has more than one letter, like "Google".

Otherwise, we define that this word doesn't use capitals in a right way.

**Example 1:**  

```
Input: "USA"
Output: True
```

**Example 2:**  

```
Input: "FlaG"
Output: False
```

**Note:** The input will be a non-empty word consisting of uppercase and lowercase latin letters.


#### Solution

Language: **Go**

```go
func detectCapitalUse(word string) bool {
    	return strings.ToLower(word) == word || strings.ToUpper(word) == word || strings.ToLower(word[1:]) == word[1:]

}
```


### [771\. Jewels and Stones](https://leetcode.com/problems/jewels-and-stones/)

Difficulty: **Easy**


You're given strings `J` representing the types of stones that are jewels, and `S` representing the stones you have.  Each character in `S` is a type of stone you have.  You want to know how many of the stones you have are also jewels.

The letters in `J` are guaranteed distinct, and all characters in `J` and `S` are letters. Letters are case sensitive, so `"a"` is considered a different type of stone from `"A"`.

**Example 1:**

```
Input: J = "aA", S = "aAAbbbb"
Output: 3
```

**Example 2:**

```
Input: J = "z", S = "ZZ"
Output: 0
```

**Note:**

*   `S` and `J` will consist of letters and have length at most 50.
*   The characters in `J` are distinct.


#### Solution

这题比较简单，只需要将宝石中的内容存到 map中，然后遍历S中的值判断J中是否有这个数即可。

Language: **Go**

```go
func numJewelsInStones(J string, S string) int {
jewel := make(map[byte]bool, len(J))
	for i := range J {
		jewel[J[i]] = true
	}
	count := 0
	for _, val := range S {
		if jewel[byte(val)] {
			count++
		}
	}
	return count
}
```

### [606\. Construct String from Binary Tree](https://leetcode.com/problems/construct-string-from-binary-tree/)

Difficulty: **Easy**


You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.

The null node needs to be represented by empty parenthesis pair "()". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree.

**Example 1:**  

```
Input: Binary tree: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     

Output: "1(2(4))(3)"
Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)".
```

**Example 2:**  

```
Input: Binary tree: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 

Output: "1(2()(4))(3)"
Explanation: Almost the same as the first example, except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.
```


#### Solution
这题的关键在于观察答案的构造，能观察到每一个子树都在一堆括号中。认识到这一点后，既可以在先序遍历的整体框架下，进行求解。
Language: **Go**

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func tree2str(t *TreeNode) string {
    	if t == nil {
		return " "
	}
	res := strconv.Itoa(t.Val)

	if t.Left == nil && t.Right == nil {
		return res
	}
	res += "(" + tree2str(t.Left) + ")"

	if t.Right != nil {
		res += "(" + tree2str(t.Right) + ")"
	}
	return res
}
```

### [961\. N-Repeated Element in Size 2N Array](https://leetcode.com/problems/n-repeated-element-in-size-2n-array/)

Difficulty: **Easy**


In a array `A` of size `2N`, there are `N+1` unique elements, and exactly one of these elements is repeated N times.

Return the element repeated `N` times.


**Example 1:**

```
Input: [1,2,3,3]
Output: 3
```


**Example 2:**

```
Input: [2,1,2,5,3,2]
Output: 2
```


**Example 3:**

```
Input: [5,1,5,2,5,3,5,4]
Output: 5
```

**Note:**

1.  `4 <= A.length <= 10000`
2.  `0 <= A[i] < 10000`
3.  `A.length` is even


#### Solution

很简单的题，除了重复元素之外，其他元素都是唯一的。
Language: **Go**

```go
func repeatedNTimes(A []int) int {
    hasseen := [10000]bool{}
	var val int
	for _, val = range A {
		if hasseen[val] {
			break
		}
		hasseen[val] = true

	}
	return val
}
```

### [942\. DI String MatchCopy for MarkdownCopy for MarkdownCopy for MarkdownCopy for Markdown](https://leetcode.com/problems/di-string-match/)

Difficulty: **Easy**


Given a string `S` that **only** contains "I" (increase) or "D" (decrease), let `N = S.length`.

Return **any** permutation `A` of `[0, 1, ..., N]` such that for all `i = 0, ..., N-1`:

*   If `S[i] == "I"`, then `A[i] < A[i+1]`
*   If `S[i] == "D"`, then `A[i] > A[i+1]`

**Example 1:**

```
Input: "IDID"
Output: [0,4,1,3,2]
```


**Example 2:**

```
Input: "III"
Output: [0,1,2,3]
```


**Example 3:**

```
Input: "DDI"
Output: [3,2,0,1]
```


**Note:**

1.  `1 <= S.length <= 10000`
2.  `S` only contains characters `"I"` or `"D"`.


#### Solution

Language: **Go**

根据题目给出的样例，可以确定，当出现I时,应该从剩下的元素中选择最小的值.当出现D时,应该从剩下的元素中选择最大的值.

根据这个解题思路,很快就可以求解出来.
```go
func diStringMatch(S string) []int {
    N := len(S)
	ans := make([]int, N+1)
	low, hight := 0, N
	for i := 0; i < N; i++ {
		if S[i] == 'I' {
			ans[i] = low
			low++
		} else {
			ans[i] = hight
			hight--
		}
	}
	ans[N] = hight
	return ans
}
```
### [728\. Self Dividing Numbers](https://leetcode.com/problems/self-dividing-numbers/)

Difficulty: **Easy**


A _self-dividing number_ is a number that is divisible by every digit it contains.

For example, 128 is a self-dividing number because `128 % 1 == 0`, `128 % 2 == 0`, and `128 % 8 == 0`.

Also, a self-dividing number is not allowed to contain the digit zero.

Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.

**Example 1:**  

```
Input: 
left = 1, right = 22
Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
```

**Note:**

*   The boundaries of each input argument are `1 <= left <= right <= 10000`.

#### Solution

简单题，直接对数字进行处理即可。
Language: **Go**

```go
func selfDividingNumbers(left int, right int) []int {
    	ans := make([]int, 0, right-left+1)
	//fmt.Println(ans)
	for i := left; i <= right; i++ {
		if diving(i) {
			ans = append(ans, i)
			//fmt.Println(ans)
		}
	}
	return ans
}

func diving(number int) bool {
	t := number
	for t > 0 {
		d := t % 10
		t = t / 10
		if d == 0 || number%d != 0 {
			return false
		}
	}
	return true

}
```

### [387\. First Unique Character in a String](https://leetcode.com/problems/first-unique-character-in-a-string/)

Difficulty: **Easy**


Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.

**Examples:**

```
s = "leetcode"
return 0.

s = "loveleetcode",
return 2.
```

**Note:** You may assume the string contain only lowercase letters.


#### Solution

Language: **Go**

```go
func firstUniqChar(s string) int {
    ans := make([]int, 26)
	for _, v := range s {
		ans[v-'a']++
	}
	for i, v := range s {
		if ans[v-'a'] == 1 {
			return i
		}
	}
	return -1
}
```

### [383\. Ransom Note](https://leetcode.com/problems/ransom-note/)

Difficulty: **Easy**


Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.

Each letter in the magazine string can only be used once in your ransom note.

**Note:**  
You may assume that both strings contain only lowercase letters.

```
canConstruct("a", "b") -> false
canConstruct("aa", "ab") -> false
canConstruct("aa", "aab") -> true
```


#### Solution
和上一题思路很相似  ，都是对每个字符串一位一位的进行处理。

Language: **Go**

```go
func canConstruct(ransomNote string, magazine string) bool {
    ret := make([]int, 26)
	for _, v := range magazine {
		ret[v-'a']++
	}

	for _, v := range ransomNote {
		if ret[v-'a'] >= 1 {
			ret[v-'a']--
		} else {
			return false
		}
	}
	return true
}
```

### [925\. Long Pressed NameCopy for MarkdownCopy for Markdown](https://leetcode.com/problems/long-pressed-name/)

Difficulty: **Easy**


Your friend is typing his `name` into a keyboard.  Sometimes, when typing a character `c`, the key might get _long pressed_, and the character will be typed 1 or more times.

You examine the `typed` characters of the keyboard.  Return `True` if it is possible that it was your friends name, with some characters (possibly none) being long pressed.

**Example 1:**

```
Input: name = "alex", typed = "aaleex"
Output: true
Explanation: 'a' and 'e' in 'alex' were long pressed.
```


**Example 2:**

```
Input: name = "saeed", typed = "ssaaedd"
Output: false
Explanation: 'e' must have been pressed twice, but it wasn't in the typed output.
```


**Example 3:**

```
Input: name = "leelee", typed = "lleeelee"
Output: true
```


**Example 4:**

```
Input: name = "laiden", typed = "laiden"
Output: true
Explanation: It's not necessary to long press any character.
```


**Note:**

1.  `name.length <= 1000`
2.  `typed.length <= 1000`
3.  The characters of `name` and `typed` are lowercase letters.


#### Solution
维护二个指针，分别指向 name 和 typed，统计同种元素出现的次数，在比较这个元素出现次数的大小比较。

Language: **Go**

```go
func isLongPressedName(name string, typed string) bool {
    if name == typed {
		return true
	}
	nameSize := len(name)
	typedSize := len(typed)

	i, j := 0, 0
	for i < nameSize && j < typedSize {
		c := name[i]
		need, pressed := 0, 0
		for i < nameSize && name[i] == c {
			need++
			i++
		}
		for j < typedSize && typed[j] == c {
			pressed++
			j++
		}
		if pressed < need {
			return false
		}
	}
	return i == nameSize && j == typedSize
}
```

### [415\. Add Strings](https://leetcode.com/problems/add-strings/)

Difficulty: **Easy**


Given two non-negative integers `num1` and `num2` represented as string, return the sum of `num1` and `num2`.

**Note:**

1.  The length of both `num1` and `num2` is < 5100.
2.  Both `num1` and `num2` contains only digits `0-9`.
3.  Both `num1` and `num2` does not contain any leading zero.
4.  You **must not use any built-in BigInteger library** or **convert the inputs to integer** directly.


#### Solution

Language: **Go**

```go
func addStrings(num1 string, num2 string) string {
    	if len(num1) > len(num2) {
		num1, num2 = num2, num1
	}

	len1, len2 := len(num1), len(num2)
	byte1, byte2 := []byte(num1), []byte(num2)

	carry := byte(0)
	ans := make([]byte, len2+1)
	ans[0] = '1'
	i := 1
	for i <= len2 {
		if i <= len1 {
			ans[len2+1-i] = byte1[len1-i] - '0'
		}
		ans[len2+1-i] += byte2[len2-i] + carry

		if ans[len2+1-i] > '9' {
			ans[len2+1-i] -= 10
			carry = byte(1)
		} else {
			carry = byte(0)
		}
		//fmt.Println("ans的长度为", len(ans))
		i++
	}
	if carry == 1 {
		return string(ans)
	}
	return string(ans[1:])
}
```